<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeQing</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-04T03:45:57.911Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HeQing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 面试知识点总结01</title>
    <link href="http://yoursite.com/2019/05/20/iOS%20%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9301/"/>
    <id>http://yoursite.com/2019/05/20/iOS 面试知识点总结01/</id>
    <published>2019-05-20T06:32:06.290Z</published>
    <updated>2019-06-04T03:45:57.911Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面试知识点总结01<br><a id="more"></a></p></blockquote><h4 id="1-UIViewController的生命周期"><a href="#1-UIViewController的生命周期" class="headerlink" title="1.UIViewController的生命周期"></a>1.UIViewController的生命周期</h4><ul><li><p>分配空间<br><code>alloc</code></p></li><li><p>初始化</p><ul><li><p>纯代码<br><code>init</code><br><code>[super init]</code>中会调用<code>initWithNibName:bundle</code></p></li><li><p>XIB初始化</p><ul><li>init初始化<br><code>init</code><br><code>initWithNibName:bundle</code></li><li>initWithNib初始化<br><code>initWithNibName:bundle</code></li></ul></li><li>StoryBoard 间接初始化<br><code>initWithCoder:</code><br><code>awakeFromNib</code></li></ul></li><li><p>之后统一调用<br><code>loadView</code><br><code>viewDidLoad</code><br><code>viewWillAppear</code><br><code>viewWillLayoutSubviews</code><br><code>viewDidLayoutSubviews</code><br><code>viewDidAppear</code><br><code>viewWillDisappear</code><br><code>viewDidDisappear</code><br><code>dealloc</code></p></li><li><p>内存不足时<br><code>didReceiveMemoryWarning</code>    </p></li></ul><p><strong>Tips:</strong></p><ul><li>当 <code>storyboard</code> 调用某个 <code>ViewController</code>，会走 <code>awakeFromNib</code>。</li><li>当建立自定义 <code>ViewController(+xib)</code> 时，不会走 <code>awakeFromNib</code>。</li><li>当建立自定义 <code>View(+xib)</code> 的时候才会走 <code>awakeFromNib</code> 方法。</li></ul><h4 id="2-iOS事件传递和事件响应"><a href="#2-iOS事件传递和事件响应" class="headerlink" title="2.iOS事件传递和事件响应"></a>2.iOS事件传递和事件响应</h4><ol><li>当一个事件发生后，事件会从父控件传给子控件，也就是说由 <code>UIApplication</code> -&gt; <code>UIWindow</code> -&gt; <code>UIView</code> -&gt; <code>fit view</code>，以上就是<strong>事件的传递</strong>，也就是寻找最合适的<code>view</code>的过程。</li><li>接下来是<strong>事件的响应</strong>。首先看 <code>fit view</code> 能否处理这个事件，如果不能则会将事件传递给其上级视图 <code>（fit view的superView）</code>；如果上级视图仍然无法处理则会继续往上传递；一直传递到视图控制器 <code>view controller</code>，首先判断视图控制器的根视图 <code>view</code> 是否能处理此事件；如果不能则接着判断该视图控制器能否处理此事件，如果还是不能则继续向上传递；（对于第二个图视图控制器本身还在另一个视图控制器中，则继续交给父视图控制器的根视图，如果根视图不能处理则交给父视图控制器处理）；一直到 <code>window</code>，如果 <code>window</code> 还是不能处理此事件则继续交给 <code>UIApplication</code> 处理，如果最后 <code>UIApplication</code> 还是不能处理此事件则将其丢弃。</li><li>在事件的响应中，如果某个控件实现了 <code>touches...</code> 方法，则这个事件将由该控件来接受，如果调用了 <code>[super touches….]</code>；就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的 <code>touches….</code> 方法。</li></ol><h4 id="3-iOS-沙盒"><a href="#3-iOS-沙盒" class="headerlink" title="3. iOS 沙盒"></a>3. iOS 沙盒</h4><p>沙盒目录：<code>Bundle Container</code>, <code>Data Container</code>, <code>iCloud Container</code>  </p><ul><li><p>Bundle Container</p><p>AppName.app: 该目录包含了应用程序本身的数据，包括资源文件和可执行文件等。整个目录是只读的，并且不会被 iTunes 同步。可通过 <code>NSString *bundlePath = [[NSBundle mainBundle] bundlePath];</code>获取到路径地址。</p></li><li><p>Data Container</p><ul><li><p>Documents/：我们可以将应用程序的数据文件保存在该目录下。该目录会被iTunes同步，可通过<br><code>NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;</code><br>获取到路径地址。</p><ul><li>Documents/Inbox：外部应用程序需要访问的文件保存在该目录下。沙盒机制是不允许外部程序访问沙盒中的文件，因此苹果的解决方案是将文件拷贝一份到应用的 Documents/Inbox 目录下。该目录只读，不可修改，会被 iTunes 同步。</li></ul></li><li><p>Library/：存放默认设置或其它状态信息。除了 Caches 子目录外其他目录都会被 iTunes 同步。</p><ul><li><p>Library/Preferences：NSUserDefaults 写的设置数据都会保存到该目录下的一个 plist 文件中，会被 iTunes 同步。</p></li><li><p>Library/Caches: iTunes 不会同步此文件夹，并且当系统空间不足的时候会被清理，适合存储体积大，不需要备份的非重要数据。可通过<code>NSString *cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;</code>获取到路径地址。</p></li></ul></li><li><p>tmp/：各种临时文件，保存应用再次启动时不需要的文件。而且，当应用不再需要这些文件时应该主动将其删除，因为该目录下的东西随时有可能被系统清理掉，目前已知的一种可能清理的原因是系统磁盘存储空间不足的时候。可通过<code>NSString *tmpPath = NSTemporaryDirectory();</code>获取到路径地址。</p></li></ul></li></ul><h4 id="4-imageNamed和imageWithContentsOfFile区别"><a href="#4-imageNamed和imageWithContentsOfFile区别" class="headerlink" title="4.imageNamed和imageWithContentsOfFile区别"></a>4.imageNamed和imageWithContentsOfFile区别</h4><ul><li><p>imageNamed<br>会在使用的时候系统会cache，程序猿是无法处理cache，这是由系统自己主动处理的。在app中一些常常会使用的,须要反复载入的,使用imageName会提升用户体验!</p></li><li><p>imageWithContentsOfFile<br>在使用完毕之后系统会释放。不会缓存下来。有些图片在应用中仅仅使用一两次的，就能够用这样的方式。比方新手引导界面的图片等等，就适合这样的方式。</p></li></ul><h4 id="5-Objective-C的面向对象中，类有真正的私有方法和私有属性么？"><a href="#5-Objective-C的面向对象中，类有真正的私有方法和私有属性么？" class="headerlink" title="5.Objective-C的面向对象中，类有真正的私有方法和私有属性么？"></a>5.Objective-C的面向对象中，类有真正的私有方法和私有属性么？</h4><p>在Java/C#等面向对象语言中，方法的访问权限可以通过public/private/protected来控制其访问权限。而在OC中，方法却并没有访问修饰符。那么，我们有没有办法使其方法变为私有？</p><ol><li><p>如果一个方法不在头文件中声明，那么这个方法在编译期，通过[receiver MethodName]的形式向对象发送消息，编译器会有警告，告诉你未找到该方法，但是实际运行时，依然可以正常运行</p><p>原因：编译时，即使这个方法不在头文件中声明，编译器仍然会将方法的签名编译进类的方法列表中, 发送消息时，会自动查找消息列表，如果找到同名消息，则会被触发）</p></li></ol><ol><li><p>如果一个方法在匿名分类中定义，那么在编译期，编译器通过[receiver MethodName]的形式向对象发送消息，编译器仍然会有警告，告诉你未找到该方法，但是实际运行时，仍然可以正常运行</p><p>原因：同上</p></li></ol><p>结论：在OC中，其实并无真正意义上的私有方法。</p><p>有真正的私有属性么？</p><ol><li><p>如果将一个属性在方法的匿名分类中定义，那么在编译期，通过obj.prop 向属性赋值时，编译器会提示错误，编译不通过。 这么看来，貌似是可以定义私有属性的。</p><p>但是。。。。</p><p>我们知道，OC中所有的方法调用都是通过消息传递，即使你使用了obj.prop 这种点语法去为对象属性赋值，其编译后的代码仍然是转换为消息的调用。</p><p>obj.prop 其实是向对象发送了一个setProp方法，等价于[obj setProp] 。 </p><p>根据上面的解释，如果你用[obj setProp] 去向这个所谓的”私有属性”赋值，仍然可以赋值成功，并且可以正常使用。</p></li></ol><p>综上，OC中其实并无真正意义上的的私有方法和私有属性。但是在实际使用中，我们应遵守规则，不能调用的方法，不调用。</p><h4 id="6-NSOperation"><a href="#6-NSOperation" class="headerlink" title="6.NSOperation"></a>6.NSOperation</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)otherQueue:(id)sender &#123;</span><br><span class="line">    //1.创建一个其他队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    </span><br><span class="line">    //最大并发数，用来设置最多可以让多少个operation同时执行。当你把它设置为 1 的时候，就是串行了(指多个operation的串行，同一个operation中的任务是并行的)</span><br><span class="line">    queue.maxConcurrentOperationCount = 1;</span><br><span class="line">    </span><br><span class="line">    //2.创建NSBlockOperation对象</span><br><span class="line">    NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 500000000; i++) &#123;</span><br><span class="line">            if (i == 0) &#123;</span><br><span class="line">                NSLog(@&quot;operation1中任务1 -&gt; 开始&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == 499999999) &#123;</span><br><span class="line">                NSLog(@&quot;operation1中任务1 -&gt; 完成&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //3.给operation1再加一个任务</span><br><span class="line">    [operation1 addExecutionBlock:^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 500000000; i++) &#123;</span><br><span class="line">            if (i == 0) &#123;</span><br><span class="line">                NSLog(@&quot;operation1中任务2 -&gt; 开始&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == 499999999) &#123;</span><br><span class="line">                NSLog(@&quot;operation1中任务2 -&gt; 完成&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    operation1.completionBlock = ^() &#123;</span><br><span class="line">        NSLog(@&quot;执行完毕&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    //4.再加一个operation2</span><br><span class="line">    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (NSInteger i = 0; i &lt; 500000000; i++) &#123;</span><br><span class="line">            if (i == 0) &#123;</span><br><span class="line">                NSLog(@&quot;operation2中任务 -&gt; 开始&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == 499999999) &#123;</span><br><span class="line">                NSLog(@&quot;operation2中任务 -&gt; 完成&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //5.加入到队列中任务自动执行,waitUntilFinished为yes会阻塞当前线程，为no不阻塞</span><br><span class="line">    [queue addOperations:@[operation1,operation2] waitUntilFinished:NO];</span><br><span class="line">    NSLog(@&quot;阻塞我没有？当前线程%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">阻塞我没有？当前线程&lt;NSThread:0xfad8o504103&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">operation1中的任务1 -&gt; 开始</span><br><span class="line">operation1中的任务2 -&gt; 开始</span><br><span class="line">operation1中的任务1 -&gt; 完成</span><br><span class="line">operation1中的任务2 -&gt; 完成</span><br><span class="line">执行完毕</span><br><span class="line">operation2中的任务 -&gt; 开始</span><br><span class="line">operation2中的任务 -&gt; 完成</span><br></pre></td></tr></table></figure><p>2个operation是串行的，但同一个operation中的多个任务是并行的</p><h4 id="7-延迟操作"><a href="#7-延迟操作" class="headerlink" title="7.延迟操作"></a>7.延迟操作</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GCD延时</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)dispatchDelay:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="comment">//非阻塞的执行方式</span></span><br><span class="line">    <span class="keyword">double</span> delayInSeconds = <span class="number">2.0</span>;</span><br><span class="line">    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"延时了2秒"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//既然谈到了延时延时，那就和其他几种延时比较下</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.此方式要求必须在主线程中执行，否则无效。是一种非阻塞的执行方式。</span></span><br><span class="line"><span class="comment">//    [self performSelector:@selector(delayMethod) withObject:nil afterDelay:1.0f];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.此方式要求必须在主线程中执行，否则无效。是一种非阻塞的执行方式，可以通过NSTimer类的- (void)invalidate;取消执行。</span></span><br><span class="line"><span class="comment">//    [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(delayMethod) userInfo:nil repeats:NO];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 此方式在主线程和子线程中均可执行。是一种阻塞的执行方式，建方放到子线程中，以免卡住界面，没有找到取消执行的方法。</span></span><br><span class="line"><span class="comment">//    [NSThread sleepForTimeInterval:4.0f];</span></span><br><span class="line"><span class="comment">//    [self delayMethod];</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"阻塞我没有？当前线程%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-framework和-a两种静态库的介绍及区别"><a href="#8-framework和-a两种静态库的介绍及区别" class="headerlink" title="8.framework和.a两种静态库的介绍及区别"></a>8.framework和.a两种静态库的介绍及区别</h4><p>.a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。</p><p>.a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用。</p><p>.a + .h + sourceFile = .framework。</p><p>.a只是静态库。framework既可以是静态库也可以是动态库。例如系统的framework就是动态库。</p><p>静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。</p><p>动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</p><p>然而苹果是不会让开发者有自己的动态库的。</p><h4 id="9-iOS-接收通知的线程一定是主线程吗？"><a href="#9-iOS-接收通知的线程一定是主线程吗？" class="headerlink" title="9.iOS 接收通知的线程一定是主线程吗？"></a>9.iOS 接收通知的线程一定是主线程吗？</h4><p>问题：在主线程中A对象监听到通知B后，调用函数functionX。然后我们开启一条子线程，在子线程中发出通知B。现在问A对象执行方法functionX时是在哪个线程？</p><blockquote><p>In a multithreaded application, notifications are always delivered in<br>the thread in which the notification was posted, which may not be the<br>same thread in which an observer registered itself.<br>官方文档说：在多线程的程序中，通知会在post通知时所在的线程被传达，这就导致了观察者注册通知的线程和收到通知的线程不在一个线程。</p></blockquote><p>经过Xcode执行后functionX是在发送通知的子线程执行的。这样的话，如果在子线程中进行UI操作的话，就会出现崩溃。因此在这种情况下，需要回到主线程进行操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;面试知识点总结01&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 学习笔记 01</title>
    <link href="http://yoursite.com/2019/05/09/Flutter/"/>
    <id>http://yoursite.com/2019/05/09/Flutter/</id>
    <published>2019-05-09T06:35:34.165Z</published>
    <updated>2019-05-24T02:46:27.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Flutter 学习笔记 01<br><a id="more"></a></p></blockquote><h3 id="Flutter知识"><a href="#Flutter知识" class="headerlink" title="Flutter知识"></a>Flutter知识</h3><h4 id="为什么Flutter-APP的Android安装包比iOS安装包小的主要原因？"><a href="#为什么Flutter-APP的Android安装包比iOS安装包小的主要原因？" class="headerlink" title="为什么Flutter APP的Android安装包比iOS安装包小的主要原因？"></a>为什么Flutter APP的Android安装包比iOS安装包小的主要原因？</h4><p>Flutter使用Skia作为其2D渲染引擎。</p><p>Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API。</p><p>目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎，值得一提的是，由于Android系统已经内置了Skia，所以Flutter在打包APK(Android应用安装包)时，不需要再将Skia打入APK中。</p><p>但iOS系统并未内置Skia，所以构建iPA时，也必须将Skia一起打包，这也是为什么Flutter APP的Android安装包比iOS安装包小的主要原因。</p><h4 id="JIT和AOT"><a href="#JIT和AOT" class="headerlink" title="JIT和AOT"></a>JIT和AOT</h4><p>目前，程序主要有两种运行方式：静态编译与动态解释。</p><p>静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为<strong>AOT</strong> （Ahead of time）即 “提前编译”；</p><p>而解释执行的则是一句一句边翻译边运行，通常将这种类型称为<strong>JIT</strong>（Just-in-time）即“即时编译”。</p><p>AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。</p><p>但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码。</p><p>也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。</p><p>在此，大家不必纠结于概念，概念就是为了传达精神而发明的，只要大家能够理解其原理即可，得其神忘其形。</p><h4 id="Flutter开发效率高"><a href="#Flutter开发效率高" class="headerlink" title="Flutter开发效率高"></a>Flutter开发效率高</h4><p>Dart运行时和编译器支持Flutter的两个关键特性的组合：</p><p><strong>基于JIT的快速开发周期</strong>：Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；</p><p><strong>基于AOT的发布包</strong>: Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能。而JavaScript则不具有这个能力。</p><h3 id="环境搭建注意点"><a href="#环境搭建注意点" class="headerlink" title="环境搭建注意点"></a>环境搭建注意点</h3><h4 id="问题1：-Flutter卡在Running-“flutter-packages-get”"><a href="#问题1：-Flutter卡在Running-“flutter-packages-get”" class="headerlink" title="问题1： Flutter卡在Running “flutter packages get”"></a>问题1： Flutter卡在Running “flutter packages get”</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 添加环境变量</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line"></span><br><span class="line">// 添加完成后</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><h4 id="问题2：使用Android-studio-新建-Flutter项目卡住"><a href="#问题2：使用Android-studio-新建-Flutter项目卡住" class="headerlink" title="问题2：使用Android studio 新建 Flutter项目卡住"></a>问题2：使用Android studio 新建 Flutter项目卡住</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create pageview_test</span><br></pre></td></tr></table></figure><p>命令行创建，Android Studio 打开</p><h4 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt;runApp(MyApp());</span><br></pre></td></tr></table></figure><p>这是一个函数，函数体只有一行，可以用 <code>=&gt;</code> 来省略<code>{}</code>，注意只有函数体只有一行时才可以这么使用。</p><h4 id="启动模拟器"><a href="#启动模拟器" class="headerlink" title="启动模拟器"></a>启动模拟器</h4><ul><li>ios <code>open -a Simulator</code>  </li><li><p>android </p><ul><li><p>在 <code>.bash_profile</code> 中配置环境变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ANDROID_SDK_ROOT=/Users/[电脑用户名]/Library/Android/sdk</span><br><span class="line">export PATH=$ANDROID_SDK_ROOT/emulator:$ANDROID_SDK_ROOT/tools:$PATH</span><br></pre></td></tr></table></figure><p>配置完成后 <code>source ~/.bash_profile</code> 刷新一下</p></li><li><p>使用 <code>emulator -list-avds</code> 命令 查看 安装的模拟器列表</p></li><li>使用 <code>emulator @模拟器名称</code> 或者 <code>emulator -avd 模拟器名称</code> 打开模拟器</li><li><p>写个脚本文件可以快捷打开</p><ul><li>进入tools文件夹   <code>/Users/[电脑用户名]/Library/Android/sdk/tools</code> </li><li><p>创建 <code>emu.sh</code> 文件  </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator -avd 本机的模拟器名称</span><br></pre></td></tr></table></figure></li><li><p><code>emu.sh</code> 启动模拟器</p></li><li>遇到 <code>permission denied</code> 错误 没有权限  <pre><code>进入到tools文件夹 执行 `chmod 777 emu.sh` 即可</code></pre></li></ul></li></ul></li></ul><h3 id="Flutter-常用组件"><a href="#Flutter-常用组件" class="headerlink" title="Flutter 常用组件"></a>Flutter 常用组件</h3><h4 id="Text-Widget"><a href="#Text-Widget" class="headerlink" title="Text Widget"></a>Text Widget</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Text Widget</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Text Widget'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">'今天是个好日子，心想的事儿都能成，今天是个好日子，赶上了春风咱笑开颜。'</span>,</span><br><span class="line">            textAlign: TextAlign.left,</span><br><span class="line">            maxLines: <span class="number">1</span>,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: TextStyle(</span><br><span class="line">              fontSize: <span class="number">25.0</span>,</span><br><span class="line">              color: Color.fromARGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">150</span>, <span class="number">150</span>),</span><br><span class="line">              decoration: TextDecoration.underline,</span><br><span class="line">              decorationStyle: TextDecorationStyle.dotted,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Contain-Widget"><a href="#Contain-Widget" class="headerlink" title="Contain Widget"></a>Contain Widget</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Container Widget</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Container Widget'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Container(</span><br><span class="line">            child: <span class="keyword">new</span> Text(<span class="string">'今天是个好日子今天是个好日子'</span>,style: TextStyle(fontSize: <span class="number">40.0</span>),),</span><br><span class="line">            alignment: Alignment.center,</span><br><span class="line">            <span class="comment">// width: 300.0,</span></span><br><span class="line">            <span class="comment">// height: 200.0,</span></span><br><span class="line">            <span class="comment">// color: Colors.lightBlue,</span></span><br><span class="line">            <span class="comment">// padding: const EdgeInsets.all(10.0),</span></span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">10.0</span>, <span class="number">20.0</span>, <span class="number">30.0</span>, <span class="number">0</span>),</span><br><span class="line">            <span class="comment">// margin: const EdgeInsets.all(10.0),</span></span><br><span class="line">            margin: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">10.0</span>, <span class="number">200.0</span>, <span class="number">10.0</span>, <span class="number">200.0</span>),</span><br><span class="line">            <span class="comment">// 注意设置了decoration就不要在设置color属性了，会冲突</span></span><br><span class="line">            decoration: <span class="keyword">new</span> BoxDecoration(</span><br><span class="line">              gradient: <span class="keyword">const</span> LinearGradient(</span><br><span class="line">                colors: [Colors.lightBlue, Colors.greenAccent, Colors.purple],</span><br><span class="line">              ),</span><br><span class="line">              border: Border.all(</span><br><span class="line">                width: <span class="number">4.0</span>,</span><br><span class="line">                color: Colors.red</span><br><span class="line">              )</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Image-Widget"><a href="#Image-Widget" class="headerlink" title="Image Widget"></a>Image Widget</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Image Widget</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Image Widget'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Container(</span><br><span class="line">            child: <span class="keyword">new</span> Image.network(</span><br><span class="line">              <span class="string">'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1690699292,1481547313&amp;fm=27&amp;gp=0.jpg'</span>,</span><br><span class="line">              scale: <span class="number">1.0</span>,</span><br><span class="line">              fit: BoxFit.contain,</span><br><span class="line">              color: Colors.greenAccent,<span class="comment">// 只设置color没有意义</span></span><br><span class="line">              colorBlendMode: BlendMode.darken,<span class="comment">// 设置混合模式</span></span><br><span class="line">              repeat: ImageRepeat.repeat,</span><br><span class="line">            ),</span><br><span class="line">            width: <span class="number">375.0</span>,</span><br><span class="line">            height: <span class="number">400.0</span>,</span><br><span class="line">            color: Colors.lightBlue,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ListView-Widget"><a href="#ListView-Widget" class="headerlink" title="ListView Widget"></a>ListView Widget</h4><p>竖向</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListView Widget</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'He Qing Demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'ListView Widget'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: ListView(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="comment">// ListTile(</span></span><br><span class="line">            <span class="comment">//   leading: Icon(Icons.access_time),</span></span><br><span class="line">            <span class="comment">//   title: Text('access_time'),</span></span><br><span class="line">            <span class="comment">// ),</span></span><br><span class="line">            <span class="comment">// ListTile(</span></span><br><span class="line">            <span class="comment">//   leading: Icon(Icons.account_balance),</span></span><br><span class="line">            <span class="comment">//   title: Text('account_balance'),</span></span><br><span class="line">            <span class="comment">// ),</span></span><br><span class="line">            Image.network(<span class="string">"https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1094983219,2445956258&amp;fm=27&amp;gp=0.jpg"</span>),</span><br><span class="line">            Image.network(<span class="string">'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1094983219,2445956258&amp;fm=27&amp;gp=0.jpg'</span>),</span><br><span class="line">            Image.network(<span class="string">'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1094983219,2445956258&amp;fm=27&amp;gp=0.jpg'</span>)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>横向 封装自己的横向listview组件 </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListView Widget 2 横向</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'ListView Widget'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Container(</span><br><span class="line">            height: <span class="number">200.0</span>,</span><br><span class="line">            child: MyList()</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView(</span><br><span class="line">      scrollDirection: Axis.horizontal,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(</span><br><span class="line">          width: <span class="number">180.0</span>,</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          width: <span class="number">180.0</span>,</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          width: <span class="number">180.0</span>,</span><br><span class="line">          color: Colors.pinkAccent,</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips: <code>vscode</code> 整体缩进快捷键 <code>tab</code> 右移 <code>shift + tab</code> 左移</p><p>动态列表</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dynamic List Widget</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp(</span><br><span class="line">  items: <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;.generate(<span class="number">1000</span>, (i) =&gt; <span class="string">'Item $i'</span>)</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; items;</span><br><span class="line">  MyApp(&#123;Key key, <span class="meta">@required</span> <span class="keyword">this</span>.items&#125;):<span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'ListView Widget'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: ListView.builder(</span><br><span class="line">          itemCount: items.length,</span><br><span class="line">          itemBuilder: (context, index) &#123;</span><br><span class="line">            <span class="keyword">return</span> ListTile(</span><br><span class="line">              title: Text(<span class="string">'<span class="subst">$&#123;items[index]&#125;</span>'</span>),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GridView-Widget"><a href="#GridView-Widget" class="headerlink" title="GridView Widget"></a>GridView Widget</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GridView Widget</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'GridView Widget'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        <span class="comment">// body: GridView.count(</span></span><br><span class="line">        <span class="comment">//   padding: EdgeInsets.all(20.0),</span></span><br><span class="line">        <span class="comment">//   crossAxisSpacing: 10.0,</span></span><br><span class="line">        <span class="comment">//   crossAxisCount: 3,</span></span><br><span class="line">        <span class="comment">//   children: &lt;Widget&gt;[</span></span><br><span class="line">        <span class="comment">//     Text('he qing'),</span></span><br><span class="line">        <span class="comment">//     Text('今天是个好日子'),</span></span><br><span class="line">        <span class="comment">//     Text('心想的事儿都能成'),</span></span><br><span class="line">        <span class="comment">//     Text('今天明天都是好日子'),</span></span><br><span class="line">        <span class="comment">//     Text('咱们老百姓'),</span></span><br><span class="line">        <span class="comment">//     Text('今天真高兴'),</span></span><br><span class="line">        <span class="comment">//   ],</span></span><br><span class="line">        <span class="comment">// ),</span></span><br><span class="line">        body: GridView(</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">2.0</span>),</span><br><span class="line">          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">            crossAxisCount: <span class="number">3</span>,</span><br><span class="line">            mainAxisSpacing: <span class="number">2.0</span>,</span><br><span class="line">            childAspectRatio: <span class="number">0.7</span>, <span class="comment">// 宽高比</span></span><br><span class="line">            crossAxisSpacing: <span class="number">2.0</span>,</span><br><span class="line">          ),</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Image.network(<span class="string">'http://pic25.nipic.com/20121205/10197997_003647426000_2.jpg'</span>,fit: BoxFit.fitHeight,),</span><br><span class="line">            Image.network(<span class="string">'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1986179278,1118313821&amp;fm=27&amp;gp=0.jpg'</span>,fit: BoxFit.fitHeight,),</span><br><span class="line">            Image.network(<span class="string">'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1979198230,3799788659&amp;fm=27&amp;gp=0.jpg'</span>,fit: BoxFit.fitHeight,),</span><br><span class="line">            Image.network(<span class="string">'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3300305952,1328708913&amp;fm=27&amp;gp=0.jpg'</span>,fit: BoxFit.fitHeight,),</span><br><span class="line">            Image.network(<span class="string">'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2153937626,1074119156&amp;fm=27&amp;gp=0.jpg'</span>,fit: BoxFit.fitHeight,),</span><br><span class="line">            Image.network(<span class="string">'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2968231382,1111539856&amp;fm=27&amp;gp=0.jpg'</span>,fit: BoxFit.fitHeight,),</span><br><span class="line">            Image.network(<span class="string">'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1451330793,2242997567&amp;fm=27&amp;gp=0.jpg'</span>,fit: BoxFit.fitHeight,),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flutter-布局"><a href="#Flutter-布局" class="headerlink" title="Flutter 布局"></a>Flutter 布局</h3><h4 id="水平布局Row"><a href="#水平布局Row" class="headerlink" title="水平布局Row"></a>水平布局Row</h4><p>灵活布局 和 不灵活布局</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'水平方向布局'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Row(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="comment">//不灵活水平布局</span></span><br><span class="line">            <span class="comment">// RaisedButton(</span></span><br><span class="line">            <span class="comment">//   onPressed: ()&#123;&#125;,</span></span><br><span class="line">            <span class="comment">//   color: Colors.redAccent,</span></span><br><span class="line">            <span class="comment">//   child: Text('红色按钮'),</span></span><br><span class="line">            <span class="comment">// ),</span></span><br><span class="line">            <span class="comment">// RaisedButton(</span></span><br><span class="line">            <span class="comment">//   onPressed: ()&#123;&#125;,</span></span><br><span class="line">            <span class="comment">//   color: Colors.blueAccent,</span></span><br><span class="line">            <span class="comment">//   child: Text('蓝色按钮'),</span></span><br><span class="line">            <span class="comment">// ),</span></span><br><span class="line">            <span class="comment">// RaisedButton(</span></span><br><span class="line">            <span class="comment">//   onPressed: ()&#123;&#125;,</span></span><br><span class="line">            <span class="comment">//   color: Colors.orangeAccent,</span></span><br><span class="line">            <span class="comment">//   child: Text('黄色按钮'),</span></span><br><span class="line">            <span class="comment">// )</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 灵活水平布局</span></span><br><span class="line">            <span class="comment">// Expanded(</span></span><br><span class="line">            <span class="comment">//   child: RaisedButton(</span></span><br><span class="line">            <span class="comment">//     onPressed: ()&#123;&#125;,</span></span><br><span class="line">            <span class="comment">//     color: Colors.redAccent,</span></span><br><span class="line">            <span class="comment">//     child: Text('红色按钮'),</span></span><br><span class="line">            <span class="comment">//   ),</span></span><br><span class="line">            <span class="comment">// ),</span></span><br><span class="line">            <span class="comment">// Expanded(</span></span><br><span class="line">            <span class="comment">//   child: RaisedButton(</span></span><br><span class="line">            <span class="comment">//     onPressed: ()&#123;&#125;,</span></span><br><span class="line">            <span class="comment">//     color: Colors.blueAccent,</span></span><br><span class="line">            <span class="comment">//     child: Text('蓝色按钮'),</span></span><br><span class="line">            <span class="comment">//   ),</span></span><br><span class="line">            <span class="comment">// ),</span></span><br><span class="line">            <span class="comment">// Expanded(</span></span><br><span class="line">            <span class="comment">//   child: RaisedButton(</span></span><br><span class="line">            <span class="comment">//     onPressed: ()&#123;&#125;,</span></span><br><span class="line">            <span class="comment">//     color: Colors.orangeAccent,</span></span><br><span class="line">            <span class="comment">//     child: Text('黄色按钮'),</span></span><br><span class="line">            <span class="comment">//   ),</span></span><br><span class="line">            <span class="comment">// ),</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 灵活水平布局 不灵活水平布局 混用</span></span><br><span class="line">            RaisedButton(</span><br><span class="line">              onPressed: ()&#123;&#125;,</span><br><span class="line">              color: Colors.redAccent,</span><br><span class="line">              child: Text(<span class="string">'红色按钮'</span>),</span><br><span class="line">            ),</span><br><span class="line">            Expanded(</span><br><span class="line">              child: RaisedButton(</span><br><span class="line">                onPressed: ()&#123;&#125;,</span><br><span class="line">                color: Colors.blueAccent,</span><br><span class="line">                child: Text(<span class="string">'蓝色按钮'</span>),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            RaisedButton(</span><br><span class="line">              onPressed: ()&#123;&#125;,</span><br><span class="line">              color: Colors.orangeAccent,</span><br><span class="line">              child: Text(<span class="string">'黄色按钮'</span>),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#### </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Flutter 学习笔记 01&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>App启动优化</title>
    <link href="http://yoursite.com/2019/05/05/App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/05/App启动优化/</id>
    <published>2019-05-05T00:47:20.043Z</published>
    <updated>2019-05-09T00:51:43.137Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>APP启动优化方案<br><a id="more"></a></p></blockquote><h3 id="App启动优化"><a href="#App启动优化" class="headerlink" title="App启动优化"></a>App启动优化</h3><h4 id="App启动的三个阶段："><a href="#App启动的三个阶段：" class="headerlink" title="App启动的三个阶段："></a>App启动的三个阶段：</h4><ol><li><code>main()</code>函数执行前；  </li><li><code>main()</code>函数执行后；  </li><li>首屏渲染完成后。</li></ol><h4 id="main-函数执行前"><a href="#main-函数执行前" class="headerlink" title="main()函数执行前"></a>main()函数执行前</h4><ol><li>加载可执行文件</li><li>加载动态链接库</li><li><code>Objc</code>运行时初始处理，相关类的注册、<code>category</code>注册、<code>selector</code>唯一性检查等</li><li>初始化，执行<code>+load()</code>方法、<code>__attribute__((constructor))</code>修饰的函数调用、创建c++静态全局变量</li></ol><p><strong>此阶段优化方案：</strong>  </p><ol><li>减少动态库加载 （可以将多个动态库合并，非系统动态库最多6个合为一个）</li><li>减少类、分类、方法（selector）的数量</li><li>用<code>+initialize</code>方法和<code>dispatch_once</code>取代所有的ObjC的<code>+load</code></li><li>减少c++全局变量的数量</li></ol><h4 id="main-函数执行后"><a href="#main-函数执行后" class="headerlink" title="main()函数执行后"></a>main()函数执行后</h4><p><strong>此阶段是指main()函数开始执行 -&gt; didFinishLaunchingWithOptions里首屏渲染方法执行完成</strong><br><strong>注意首页业务代码是在首屏渲染完成前执行</strong></p><ol><li>首屏相关基础库初始化</li><li>首屏相关业务数据读取和处理</li><li>首屏渲染的大量计算</li></ol><p><strong>此阶段优化方案</strong></p><ol><li>各种初始化工作，不要都放到此阶段里面，会导致首屏渲染滞后。启动必要初始化，首屏渲染必要初始化，可以放在此阶段。其他的初始化放到对应功能使用之前。</li></ol><h4 id="首屏渲染完成后"><a href="#首屏渲染完成后" class="headerlink" title="首屏渲染完成后"></a>首屏渲染完成后</h4><p><strong>此阶段是指 didFinishLaunchingWithOptions 方法作用域内首屏渲染之后的所有方法执行完成</strong></p><ol><li>非首屏其他业务服务模块的初始化</li><li>监听的注册</li><li>配置文件的读取等</li></ol><p><strong>此阶段首页信息已经显示完成</strong><br><strong>此阶段优化方案</strong></p><ol><li>主要优化主线程耗时方法，滞后执行或者异步执行，因为此阶段已经显示首页，主要优化用户的交互。</li></ol><h3 id="App启动速度的监控"><a href="#App启动速度的监控" class="headerlink" title="App启动速度的监控"></a>App启动速度的监控</h3><p>通过在工程的scheme中添加环境变量<code>DYLD_PRINT_STATISTICS</code>，设置值为1，App启动加载时Xcode的控制台就会有pre-main各个阶段的详细耗时输出。</p><p>另外两种方法：</p><h4 id="第一种方法：定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时"><a href="#第一种方法：定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时" class="headerlink" title="第一种方法：定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时"></a>第一种方法：定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时</h4><p>Time Profiler 就是采用这种方式。</p><p><strong>注意点</strong>  </p><ol><li>定时间隔长则会漏掉某些耗时短的方法  </li><li>定时间隔短，抓取堆栈的方法本身会频繁调用，影响整体耗时</li></ol><p>一般设置0.01秒，对整体耗时影响小，但是检测的很多方法耗时就不准确了。不过整体耗时数据比较重要，单个耗时不准可以接受。<br>如果设置0.002秒基本所有方法都可以检测，整体耗时就不准了。</p><h4 id="第二种方法：对-objc-msgSend-方法进行hook来掌握所有方法的耗时"><a href="#第二种方法：对-objc-msgSend-方法进行hook来掌握所有方法的耗时" class="headerlink" title="第二种方法：对 objc_msgSend 方法进行hook来掌握所有方法的耗时"></a>第二种方法：对 objc_msgSend 方法进行hook来掌握所有方法的耗时</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;APP启动优化方案&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令行总结</title>
    <link href="http://yoursite.com/2019/04/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/01/Git常用命令行总结/</id>
    <published>2019-04-01T06:48:30.595Z</published>
    <updated>2019-04-01T06:48:30.595Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Git常用命令行总结<br><a id="more"></a></p></blockquote><h4 id="一、本地管理"><a href="#一、本地管理" class="headerlink" title="一、本地管理"></a>一、本地管理</h4><ul><li><p>提交操作  </p><ul><li>配置全局用户名和邮箱<ul><li>配置用户名 :<br><code>git config --global user.name &quot;hq&quot;</code> </li><li>配置邮箱 :<br><code>git config --global user.email &quot;hq@163.com&quot;</code> </li><li>获取全局配置信息 :<br><code>git config --list</code>  </li></ul></li><li><p>创建仓库<br>cd到你想要创建仓库的地址<br>运行<code>git init</code>。</p></li><li><p>忽略文件有时候有些文件我们不想每次提交，那么我们可以配置<code>.gitignore</code>，并把它放到根目录，忽略该文件的效果。<br>eg：在里面添加 <code>.DS_Store</code>，则不会对该文件的修改加入到工作区中。<br>有些已经跑过的项目，你会发现你在<code>.gitignore</code>加入 <code>xcuserdata/</code> 后，<code>UserInterfaceState.xcuserstate</code>这个文件还是频繁更新。<br>去掉这个文件的具体步骤如下：到目录下把这个文件直接干掉，然后<code>commit</code>这次修改，重启Xcode就好了。或者使用命令行：<code>git rm --cached</code> 该文件路径<code>git commit -m &quot;Removed stupid file&quot;</code></p></li><li><p>查看仓库的当前状态<code>git status</code>   </p></li><li><p>查看当前文件状态<code>git diff</code>   </p></li><li><p>查看当前改动<code>git diff HEAD -- filename</code>  </p></li><li><p>查看该文件工作区与当前版本库的差别</p></li><li><p>查看之前的所有<code>log</code><br><code>git log</code> 查看详细改动<br><code>git log --pretty=oneline</code> 简单方式查看版本改动</p></li><li><p>从工作区添加到暂存区<br><code>git add filename.txt</code> 添加单个文件<br><code>git add *.txt</code> 添加所有txt文件<br><code>git add .</code> 添加所有文件</p></li><li><p>丢弃工作区中的修改<br><code>git checkout -- filename</code> 丢弃对应文件的修改<br><code>git checkout head .</code> 丢弃所有工作区的修改</p></li><li><p>将暂存的修改还原到工作区<br><code>git reset head</code> 或者 <code>git reset head filename</code></p></li><li><p>将暂存区的改动上传到仓库<br><code>git commit -m &quot;commitSomething&quot;</code></p></li><li><p>版本回归首先，<code>Git</code>必须知道当前版本是哪个版本，在<code>Git</code>中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>74399b158f9c557486c0f0074483e78f1184bb7c</code>（注意我的提交ID和你的肯定不一样），<br>上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。<br>在这里，介绍一下 <code>--hard --soft --mix(默认)</code>  </p><ul><li><p><code>git reset --mixed</code>：此为默认方式，不带任何参数的<code>git reset</code>，即时这种方式，它回退到某个版本，只保留源码，回退<code>commit</code>和<code>index</code>信息  </p></li><li><p><code>git reset --soft</code>：回退到某个版本，只回退了<code>commit</code>的信息，不会恢复到<code>index file</code>一级。如果还要提交，直接<code>commit</code>即可</p></li><li><p><code>Git reset  --hard</code>：彻底回退到某个版本，本地的源码也会变为上一个版本的内容</p><p><code>git reset --hard HEAD^</code> 回滚到上一个版本。如果回滚错了，在没关闭命令行的前提下，找到上次<code>git log</code>的日志，找到对应的版本号，输入<code>git reset --hard 74399b158f9c557486c0f0074483e78f1184bb7c</code> 即可恢复。如果关闭了命令行，通过 <code>git reflog</code>，查看所有版本号。</p></li></ul></li></ul></li><li><p>分支管理</p><ul><li><p>创建分支<code>git checkout -b branchName</code><br>(相当与: <code>git branch branchName</code><br><code>git checkout branchName</code>两句命令)<br><code>git branch branchName b281e9cd7048a3ad70b5159ba47d4205eb476608</code>  在指定节点创建分支</p><ul><li><p>查看当前所有分支以及状态<code>git branch</code></p></li><li><p>合并分支<code>git merge branchName</code>   用于合并指定分支到当前分支</p></li><li><p>删除分支<code>git branch -d branchName</code>  删除指定分支</p></li></ul></li></ul></li></ul><h4 id="二、远程管理"><a href="#二、远程管理" class="headerlink" title="二、远程管理"></a>二、远程管理</h4><ul><li><p>首先登陆github创建一个远程仓库，获取到远程仓库的地址。（<code>https://git.oschina.net/hq/gitTest.git</code>）</p></li><li><p>克隆远程仓库<code>git clone https://git.oschina.net/hq/gitTest.git</code></p></li><li><p>查看本地远程仓库状态<code>git remote -v</code></p></li><li><p>链接远程仓库<code>git remote add origin https://git.oschina.net/hq/gitTest.git</code></p></li><li><p>清除远程仓库<code>git remote rm origin</code></p></li><li><p>获取远程库数据单不合并<code>git fetch origin</code></p></li><li><p>将本地分支推送到远程分支并合并<code>git push origin master:master</code>    master为分支名，前面的master为本地分支名，后面的master为远程分支名</p></li><li><p>获取并合并远程分支的两种方法</p><ul><li>第一种:使用<code>git fetch</code> 获取到当前最新的远程分支，然后使用<code>git merge origin/master</code> 进行合并。</li><li>第二种：直接使用 <code>git pull origin master:master</code> 获取并直接合并到对应分支。针对两种获取合并方式，个人更推崇第一种，首先可以知道队友都改了些什么，另外可以准确的进行一对多的合并。</li></ul></li></ul><h4 id="三、冲突解决"><a href="#三、冲突解决" class="headerlink" title="三、冲突解决"></a>三、冲突解决</h4><p>对于部分新手来说，解决冲突可以说是头疼的问题。目前有两种解决冲突的方式。</p><p>冲突后文件显示 </p><ul><li><p>第一种：修改当前文件，也就是说在你编辑的文件中直接修改然后<code>git add .</code>，<code>git commit -m “mergeok”</code>，手动保留你想要的修改。</p></li><li><p>第二种：自动解决冲突的工具，不过我还是不叫喜欢第一种，可控性强。</p></li></ul><h4 id="四、标签操作"><a href="#四、标签操作" class="headerlink" title="四、标签操作"></a>四、标签操作</h4><ul><li><p><code>git tag v1.0.0</code> (后面可加版本号在固定节点打上tag)</p></li><li><p><code>git tag</code>查看所有标签。</p></li><li><p><code>git tag -d v1.0.0</code>删除名称为v1.0.0的本地标签</p></li><li><p><code>git push origin :refs/tags/v1.0.0</code>删除名称为v1.0.0的远程仓库标签</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Git常用命令行总结&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS静态分析工具</title>
    <link href="http://yoursite.com/2019/03/29/iOS%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/03/29/iOS静态分析工具/</id>
    <published>2019-03-29T09:37:07.313Z</published>
    <updated>2019-03-29T09:38:03.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>iOS静态分析工具方式探究<br><a id="more"></a></p></blockquote><h4 id="iOS静态分析工具"><a href="#iOS静态分析工具" class="headerlink" title="iOS静态分析工具"></a>iOS静态分析工具</h4><ul><li><p>OCLint  </p><ul><li><p>安装</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 首先设置brew的第三方库</span><br><span class="line">brew tap oclint/formulae</span><br><span class="line">// 安装</span><br><span class="line">brew install oclint</span><br></pre></td></tr></table></figure><ul><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 编写hello world代码，创建Hello.m文件</span><br><span class="line">// 用OClint检查</span><br><span class="line">oclint Hello.m</span><br><span class="line">// 结果生成html文件</span><br><span class="line">oclint -report-type html -o report.html Hello.m</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>Clang静态分析器   </p><ul><li><p>常用的两个工具   </p><ul><li><p>scan-build<br> 用来运行分析器的命令行工具</p></li><li><p>scan-view<br> 包含了scan-build的工具，将scan-build执行的结果可视化</p></li><li><p>使用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 项目目录下</span><br><span class="line">\yourpath\scan-build -k -V make</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Clang静态分析器由分析引擎（analyzer core）和 checkers 组成  </p><ul><li><p>checker基于底层分析引擎之上，通过分析引擎提供的功能我们可以编写新的checker</p></li><li><p>列出当前Clang版本下所有的checker</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">clang -analyze -Xclang -analyzer-checker-help</span><br><span class="line"></span><br><span class="line">debug.ConfigDumper              配置表</span><br><span class="line">debug.DumpCFG                   显示控制流程图</span><br><span class="line">debug.DumpCallGraph             显示调用图</span><br><span class="line">debug.DumpCalls                 打印引擎遍历的调用</span><br><span class="line">debug.DumpDominators            打印控制流程图的 dominance tree</span><br><span class="line">debug.DumpLiveVars              打印实时变量分析结果</span><br><span class="line">debug.DumpTraversal             打印引擎遍历的分支条件</span><br><span class="line">debug.ExprInspection            检查分析器对表达式的理解</span><br><span class="line">debug.Stats                     使用分析器统计信息发出警告</span><br><span class="line">debug.TaintTest                 标记污染的符号</span><br><span class="line">debug.ViewCFG                   查看控制流程图</span><br><span class="line">debug.ViewCallGraph             使用 GraphViz 查看调用图</span><br><span class="line">debug.ViewExplodedGraph         使用 GraphViz 查看分解图</span><br></pre></td></tr></table></figure></li><li><p>如何使用checker</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    a = b;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用DumpCFG这个Checker对其进行分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -cc1 -analyze -analyzer-checker=debug.DumpCFG</span><br></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"> [B2 (ENTRY)]</span><br><span class="line">   Succs (1): B1</span><br><span class="line"></span><br><span class="line"> [B1]</span><br><span class="line">   1: int a;</span><br><span class="line">   2: 10</span><br><span class="line">   3: int b = 10;</span><br><span class="line">   4: b</span><br><span class="line">   5: [B1.4] (ImplicitCastExpr, LValueToRValue, int)</span><br><span class="line">   6: a</span><br><span class="line">   7: [B1.6] = [B1.5]</span><br><span class="line">   8: a</span><br><span class="line">   9: [B1.8] (ImplicitCastExpr, LValueToRValue, int)</span><br><span class="line">  10: return [B1.9];</span><br><span class="line">   Preds (1): B2</span><br><span class="line">   Succs (1): B0</span><br><span class="line"></span><br><span class="line">  [B0 (EXIT)]</span><br><span class="line">   Preds (1): B</span><br></pre></td></tr></table></figure><p>控制流程图把程序拆分的更加详细，有助于我们分析</p></li></ul></li></ul></li></ul></li><li><p>infer</p><pre><code>- 安装   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   brew install infer</span><br><span class="line">   ``` </span><br><span class="line">- 使用</span><br></pre></td></tr></table></figure>infer -- clang -c Hello.m<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- 工作流程</span><br><span class="line"></span><br><span class="line">   ```mermaid</span><br><span class="line">   graph LR</span><br><span class="line">       A[类c语言] --&gt; B[Clang]</span><br><span class="line">       C[Java语言] --&gt; D[javac]</span><br><span class="line">       B --&gt; E[Infer-out]</span><br><span class="line">       D --&gt; E</span><br><span class="line">       E --&gt; F[问题]</span><br><span class="line">       F --&gt; G[问题]</span><br><span class="line">       G --&gt; H[...]</span><br><span class="line">       F -.-&gt; I[report.json]</span><br><span class="line">       G -.-&gt; I</span><br><span class="line">       H -.-&gt; I</span><br></pre></td></tr></table></figure></code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS静态分析工具方式探究&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 234. 回文链表</title>
    <link href="http://yoursite.com/2019/03/28/LeetCode%20234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/03/28/LeetCode 234. 回文链表/</id>
    <published>2019-03-28T08:11:07.838Z</published>
    <updated>2019-03-28T08:11:07.838Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LeetCode 234. 回文链表<br><a id="more"></a></p></blockquote><h4 id="LeetCode-234-回文链表"><a href="#LeetCode-234-回文链表" class="headerlink" title="LeetCode 234. 回文链表"></a>LeetCode 234. 回文链表</h4><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>输入: 1-&gt;2<br>输出: false  </p><p>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true  </p><p>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h4 id="Python方法"><a href="#Python方法" class="headerlink" title="Python方法"></a>Python方法</h4><ol><li>使用快慢指针找到链表中点。 </li><li>逆序后半部分。 </li><li>两部分从头结点开始比较是否相同。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="comment"># 找到中间的节点</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="comment"># 后半段逆序</span></span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        nxt = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> slow:</span><br><span class="line">            nxt = slow.next</span><br><span class="line">            slow.next = pre</span><br><span class="line">            pre = slow</span><br><span class="line">            slow = nxt</span><br><span class="line">        <span class="comment"># 比较前半段和后半段节点</span></span><br><span class="line">        <span class="keyword">while</span> pre <span class="keyword">and</span> head:</span><br><span class="line">            <span class="keyword">if</span> pre.val != head.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LeetCode 234. 回文链表&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS Tagged Pointer</title>
    <link href="http://yoursite.com/2019/03/25/iOS%20Tagged%20Pointer/"/>
    <id>http://yoursite.com/2019/03/25/iOS Tagged Pointer/</id>
    <published>2019-03-25T02:23:46.243Z</published>
    <updated>2019-03-25T02:23:46.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。<br><a id="more"></a></p></blockquote><h4 id="iOS程序的内存布局"><a href="#iOS程序的内存布局" class="headerlink" title="iOS程序的内存布局"></a>iOS程序的内存布局</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">保留  低</span><br><span class="line">-------------</span><br><span class="line">代码区（__TEXT）</span><br><span class="line">-------------</span><br><span class="line">数据区（__DATA）</span><br><span class="line">  字符串常量</span><br><span class="line">  已初始化的数据</span><br><span class="line">  未初始化的数据</span><br><span class="line">-------------</span><br><span class="line">堆（heap）↓</span><br><span class="line">-------------</span><br><span class="line">栈（stack)↑</span><br><span class="line">-------------</span><br><span class="line">内核区高</span><br></pre></td></tr></table></figure><ul><li>代码区：编译之后的代码</li><li>数据段<ul><li>字符串常量：比如<code>NSString *str = @&quot;123&quot;</code></li><li>已初始化数据：已初始化的全局变量、静态变量等</li><li>未初始化数据：未初始化的全局变量、静态变量等</li></ul></li><li>栈：函数调用开销，比如局部变量。分配的内存空间地址越来越小</li><li>堆：通过alloc、malloc、calloc等动态分配的空间，分配的内存空间地址越来越大</li></ul><h4 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h4><ul><li><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储。</p></li><li><p>在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值。</p></li><li><p>使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。</p></li><li><p>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据。</p></li><li><p><code>objc_msgSend</code>能识别<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，节省了以前的调用开销。</p></li><li><p>如何判断一个指针是否为Tagged Pointer？  </p><ul><li>iOS平台，最高有效位是1（第64bit）  </li><li>Mac平台，最低有效位是1</li></ul></li></ul><h4 id="判断是否为Tagged-Pointer"><a href="#判断是否为Tagged-Pointer" class="headerlink" title="判断是否为Tagged Pointer"></a>判断是否为Tagged Pointer</h4><p>在OC源码中发现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   define _OBJC_TAG_MASK (1UL<span class="meta-string">&lt;&lt;63)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#else</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_MASK 1UL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#endif</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">static inline bool </span></span></span><br><span class="line"><span class="meta"><span class="meta-string">_objc_isTaggedPointer(const void * _Nullable ptr) </span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h4><p>以下两段代码会发生什么事？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abcdefghijk"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abc"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一段代码会崩溃，<code>Thread 3: EXC_BAD_ACCESS (code=1, address=0x14a99517b500)</code>。  </p><p>因为第一段代码字符串比较长，所以存储的对象方式。<br>调用set方法赋值，最终会走下面的代码，（arc底层也会转成mrc方式）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_name != name) &#123;</span><br><span class="line">        [_name release];</span><br><span class="line">        _name = [name <span class="keyword">retain</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看出<code>[_name release]</code>可能会多次释放，造成坏内存访问。</p><p>解决方法<code>@property (strong, nonatomic) NSString *name;</code></p><ul><li><code>nonatomic</code>改成<code>atomic</code></li><li>加锁<code>self.name = [NSString stringWithFormat:@&quot;abcdefghijk&quot;];</code></li></ul><p>第二段代码正常运行。</p><p>因为第二段的字符串比较短，存储方式为<code>Tagged Pointer</code>，不走set方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 232 用栈实现队列</title>
    <link href="http://yoursite.com/2019/03/18/LeetCode%20232%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/03/18/LeetCode 232 用栈实现队列/</id>
    <published>2019-03-18T02:53:54.498Z</published>
    <updated>2019-03-18T02:53:54.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LeetCode 232 用栈实现队列<br><a id="more"></a></p></blockquote><h4 id="LeetCode-232-用栈实现队列"><a href="#LeetCode-232-用栈实现队列" class="headerlink" title="LeetCode 232 用栈实现队列"></a>LeetCode 232 用栈实现队列</h4><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。  </p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // 返回 1</span><br><span class="line">queue.pop();   // 返回 1</span><br><span class="line">queue.empty(); // 返回 false</span><br></pre></td></tr></table></figure><p>说明:</p><p>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</p><h4 id="python解法"><a href="#python解法" class="headerlink" title="python解法"></a>python解法</h4><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>        <span class="string">"""</span><span class="string">        Initialize your data structure here.</span><span class="string">        """</span>        self.inStack, self.outStack = [], []    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span>        <span class="string">"""</span><span class="string">        Push element x to the back of queue.</span><span class="string">        """</span>        self.inStack.append(x)    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span>        <span class="string">"""</span><span class="string">        Removes the element from in front of queue and returns that element.</span><span class="string">        """</span>        self.move()        <span class="keyword">return</span> self.outStack.pop()    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span> -&gt; int:</span>        <span class="string">"""</span><span class="string">        Get the front element.</span><span class="string">        """</span>        self.move()        <span class="keyword">return</span> self.outStack[<span class="number">-1</span>]    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span> -&gt; bool:</span>        <span class="string">"""</span><span class="string">        Returns whether the queue is empty.</span><span class="string">        """</span>        <span class="keyword">return</span> (<span class="keyword">not</span> self.inStack) <span class="keyword">and</span> (<span class="keyword">not</span> self.outStack)    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self)</span>:</span>        <span class="string">"""</span><span class="string">        :rtype nothing</span><span class="string">        """</span>        <span class="keyword">if</span> <span class="keyword">not</span> self.outStack:            <span class="keyword">while</span> self.inStack:                self.outStack.append(self.inStack.pop())</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LeetCode 232 用栈实现队列&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD定时器封装</title>
    <link href="http://yoursite.com/2019/03/18/GCD%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2019/03/18/GCD定时器封装/</id>
    <published>2019-03-18T02:38:21.165Z</published>
    <updated>2019-03-18T02:38:21.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时。<br><a id="more"></a></p></blockquote><h4 id="GCD定时器封装"><a href="#GCD定时器封装" class="headerlink" title="GCD定时器封装"></a>GCD定时器封装</h4><p><code>NSTimer</code>依赖于<code>RunLoop</code>，如果<code>RunLoop</code>的任务过于繁重，可能会导致<code>NSTimer</code>不准时。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HQTimer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTask:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))task</span><br><span class="line">                 start:(<span class="built_in">NSTimeInterval</span>)start</span><br><span class="line">              interval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">               repeats:(<span class="built_in">BOOL</span>)repeats</span><br><span class="line">                 async:(<span class="built_in">BOOL</span>)async;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTask:(<span class="keyword">id</span>)target</span><br><span class="line">              selector:(SEL)selector</span><br><span class="line">                 start:(<span class="built_in">NSTimeInterval</span>)start</span><br><span class="line">              interval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">               repeats:(<span class="built_in">BOOL</span>)repeats</span><br><span class="line">                 async:(<span class="built_in">BOOL</span>)async;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)cancelTask:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HQTimer</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *timers_;</span><br><span class="line">dispatch_semaphore_t semaphore_;</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        timers_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        semaphore_ = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSString</span> *)execTask:(<span class="keyword">id</span>)target selector:(SEL)selector start:(<span class="built_in">NSTimeInterval</span>)start interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats async:(<span class="built_in">BOOL</span>)async &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!target || !selector) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> execTask:^&#123;</span><br><span class="line">        <span class="keyword">if</span> ([target respondsToSelector:selector]) &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">            [target performSelector:selector];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; start:start interval:interval repeats:repeats async:async];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))task start:(<span class="built_in">NSTimeInterval</span>)start interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats async:(<span class="built_in">BOOL</span>)async &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!task || start &lt; <span class="number">0</span> || (interval &lt;= <span class="number">0</span> &amp;&amp; repeats)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = async ? dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>) : dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置时间</span></span><br><span class="line">    dispatch_source_set_timer(timer,</span><br><span class="line">                              dispatch_time(DISPATCH_TIME_NOW, start * <span class="built_in">NSEC_PER_SEC</span>),</span><br><span class="line">                              interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="comment">// 定时器的唯一标识</span></span><br><span class="line">    <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%zd"</span>, timers_.count];</span><br><span class="line">    <span class="comment">// 存放到字典中</span></span><br><span class="line">    timers_[name] = timer;</span><br><span class="line">    dispatch_semaphore_signal(semaphore_);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置回调</span></span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        task();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!repeats) &#123; <span class="comment">// 不重复的任务</span></span><br><span class="line">            [<span class="keyword">self</span> cancelTask:name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)cancelTask:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (name.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t timer = timers_[name];</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timer);</span><br><span class="line">        [timers_ removeObjectForKey:name];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_signal(semaphore_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    [HQTimer execTask:^&#123;</span></span><br><span class="line"><span class="comment">//        NSLog(@"111111---%@",[NSThread currentThread]);</span></span><br><span class="line"><span class="comment">//    &#125; start:2.0 interval:1 repeats:YES async:YES];</span></span><br><span class="line">    </span><br><span class="line">    [HQTimer execTask:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task) start:<span class="number">2</span> interval:<span class="number">1</span> repeats:<span class="literal">YES</span> async:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)task&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"111111---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="GCD定时器" scheme="http://yoursite.com/tags/GCD%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 239 滑动窗口最大值</title>
    <link href="http://yoursite.com/2019/03/15/LeetCode%20239%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2019/03/15/LeetCode 239 滑动窗口最大值/</id>
    <published>2019-03-15T02:59:16.540Z</published>
    <updated>2019-03-18T02:51:38.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LeetCode 239 滑动窗口最大值<br><a id="more"></a></p></blockquote><h4 id="LeetCode-239-滑动窗口最大值"><a href="#LeetCode-239-滑动窗口最大值" class="headerlink" title="LeetCode 239 滑动窗口最大值"></a>LeetCode 239 滑动窗口最大值</h4><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口最大值。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p>注意：</p><p>你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。</p><p>Python解法：<br>双端队列deque</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        res, window = [], []</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            当窗口移动过程中，右侧即将加入新值的时候，判断左侧的值是否需要移除</span></span><br><span class="line"><span class="string">            条件一：i&gt;=k 判断新值的下标是否已经大于窗口（队列）的容量</span></span><br><span class="line"><span class="string">            条件二：window[0] &lt;= i - k 是判断窗口是否是装满的 因为下面会移动过程中可能会把小的元素移除</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k <span class="keyword">and</span> window[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                window.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            即将加入新值时，把窗口里面的存的下标对应的值比新值小的移除</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">while</span> window <span class="keyword">and</span> nums[window[<span class="number">-1</span>]] &lt;= x:</span><br><span class="line">                window.pop()</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            窗口添加新值的下标</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            window.append(i)</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            将最大值添加到结果集中 </span></span><br><span class="line"><span class="string">            i &gt;= k -1 窗口完全滑进数组是开始添加</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k <span class="number">-1</span>:</span><br><span class="line">                res.append(nums[window[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LeetCode 239 滑动窗口最大值&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="双端队列" scheme="http://yoursite.com/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CADisplayLink、NSTimer 循环引用以及解决方法</title>
    <link href="http://yoursite.com/2019/03/13/CADisplayLink%E3%80%81NSTimer%20%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/13/CADisplayLink、NSTimer 循环引用以及解决方法/</id>
    <published>2019-03-13T02:35:26.092Z</published>
    <updated>2019-03-13T02:36:23.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CADisplayLink、NSTimer使用不当会产生循环引用<br><a id="more"></a></p></blockquote><h4 id="CADisplayLink、NSTimer使用不当会产生循环引用"><a href="#CADisplayLink、NSTimer使用不当会产生循环引用" class="headerlink" title="CADisplayLink、NSTimer使用不当会产生循环引用"></a>CADisplayLink、NSTimer使用不当会产生循环引用</h4><p><code>CADisplaylink</code>、<code>NSTimer</code>会对<code>target</code>产生强引用，如果<code>target</code>又对它们产生强引用，那么就会发生循环引用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CADisplayLink</span> *link;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用频率和屏幕的刷帧频率一致，60FPS</span></span><br><span class="line">    <span class="keyword">self</span>.link = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(linkTest)];</span><br><span class="line">    [<span class="keyword">self</span>.link addToRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    __weak typeof(self) weakSelf = self;</span></span><br><span class="line"><span class="comment">//    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span></span><br><span class="line"><span class="comment">//        [weakSelf timerTest];</span></span><br><span class="line"><span class="comment">//    &#125;];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)linkTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    [<span class="keyword">self</span>.link invalidate];</span><br><span class="line"><span class="comment">//    [self.timer invalidate];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>以上代码当控制器销毁的时候，不会走<code>dealloc</code>方法。<code>linkTest</code>方法会一直调用。<br><code>__weak typeof(self) weakSelf = self;</code>的解决方法只适用于<code>block</code>的情况。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用代理对象<code>NSProxy</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSProxy</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Classisa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)alloc;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NSProxy</code>类是与<code>NSObject</code>类同级别的基类。并且<code>NSProxy</code>类没有<code>init</code>方法，只有<code>alloc</code>方法。  </p><p>创建一个代理类继承自<code>NSProxy</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HQProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="comment">// 注意此处是weak修饰target </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HQProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    HQProxy *proxy = [MJProxy alloc]; <span class="comment">// 没有init方法</span></span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取消息签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息转发</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>NSProxy</code>实例对象收到消息首先会在自己的类对象的方法列表中查找有没有对应的方法<br>如果没有会直接进入消息转发转发给它内部的<code>target</code>对象处理，不会再在自己的父类的方法列表中查找<br>这样就提高了效率。</p><p>回到<code>viewcontroller</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向`[HQProxy proxyWithTarget:self]`这个对象发送`timerTest`消息，传过去的`target`是`self`。</span></span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:[HQProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(timerTest) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果不会产生循环引用。控制器销毁会进入<code>dealloc</code>方法。</p><p>流程图如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">C[ViewController targrt] --&gt; A[NSTimer target]</span><br><span class="line">A --&gt; B[NSProxy targrt]</span><br><span class="line">B -.-&gt; C</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;CADisplayLink、NSTimer使用不当会产生循环引用&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="循环引用" scheme="http://yoursite.com/tags/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的读写安全方案</title>
    <link href="http://yoursite.com/2019/03/08/iOS%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E5%AE%89%E5%85%A8%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/03/08/iOS中的读写安全方案/</id>
    <published>2019-03-08T08:51:08.196Z</published>
    <updated>2019-03-11T03:38:00.016Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>iOS中的读写安全方案<br><a id="more"></a></p></blockquote><h4 id="iOS中的读写安全方案"><a href="#iOS中的读写安全方案" class="headerlink" title="iOS中的读写安全方案"></a>iOS中的读写安全方案</h4><ul><li>同一时间，只能有一个线程进行写操作</li><li>同一时间，允许多个线程进行读操作</li><li>同一时间，不允许既有写操作，又有读操作</li></ul><h4 id="方案一：pthread-rwlock读写锁"><a href="#方案一：pthread-rwlock读写锁" class="headerlink" title="方案一：pthread_rwlock读写锁"></a>方案一：<code>pthread_rwlock</code>读写锁</h4><p>导入头文件<code>#import &lt;pthread.h&gt;</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_rwlock_t lock;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> write];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write</span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案二：dispatch-barrier-async异步栅栏函数"><a href="#方案二：dispatch-barrier-async异步栅栏函数" class="headerlink" title="方案二：dispatch_barrier_async异步栅栏函数"></a>方案二：<code>dispatch_barrier_async</code>异步栅栏函数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.queue = dispatch_queue_create(<span class="string">"rw_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        dispatch_barrier_async(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> write];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"read"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write</span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"write"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>dispatch_barrier_async</code>必须使用自己创建的并行队列才有效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS中的读写安全方案&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="读写安全" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS atomic 原子性</title>
    <link href="http://yoursite.com/2019/03/07/iOS%20atomic%20%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <id>http://yoursite.com/2019/03/07/iOS atomic 原子性/</id>
    <published>2019-03-07T01:33:40.062Z</published>
    <updated>2019-03-07T01:51:25.114Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>atomic</code>用于保证属性<code>setter、getter</code>的原子性操作，相当于在<code>getter</code>和<code>setter</code>内部加了线程同步锁<br><a id="more"></a></p></blockquote><h4 id="atomic-原子性"><a href="#atomic-原子性" class="headerlink" title="atomic 原子性"></a>atomic 原子性</h4><p><code>atomic</code>用于保证属性<code>setter、getter</code>的原子性操作，相当于在<code>getter</code>和<code>setter</code>内部加了线程同步锁  </p><p>源码在<code>objc4</code>的<code>objc-accessors.mm</code>里面可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reallySetProperty</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> copy, <span class="keyword">bool</span> mutableCopy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_getProperty</span><span class="params">(id self, SEL _cmd, <span class="keyword">ptrdiff_t</span> offset, BOOL atomic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain release world</span></span><br><span class="line">    id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    id value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它并不能保证使用属性的过程是线程安全的<br>例如属性为一个数组，对数组进行set、get方法的调用是线程安全的<br>但是往数组中添加元素的过程不是线程安全的，需要另外加锁 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="literal">NULL</span>, ^&#123;</span><br><span class="line">        <span class="comment">// 加锁 set</span></span><br><span class="line">        p.data = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 加锁 get   </span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = p.data;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁 添加元素</span></span><br><span class="line">[array addObject:<span class="string">@"1"</span>];</span><br><span class="line">[array addObject:<span class="string">@"2"</span>];</span><br><span class="line">[array addObject:<span class="string">@"3"</span>];</span><br><span class="line"><span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p><code>atomic</code>比较耗费性能，在iOS中使用比较少，在mac编程中使用较多。<br>iOS一般对同一个属性的读写都在同一线程，且操作比较频繁。因此使用<code>nonatomic</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;atomic&lt;/code&gt;用于保证属性&lt;code&gt;setter、getter&lt;/code&gt;的原子性操作，相当于在&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;内部加了线程同步锁&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Static 静态变量</title>
    <link href="http://yoursite.com/2019/03/01/static-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2019/03/01/static-静态变量/</id>
    <published>2019-03-01T08:44:17.342Z</published>
    <updated>2019-03-04T01:31:26.113Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用关键字<code>static</code>修饰全局变量，则该变量就被定义成为一个静态全局变量。<br><a id="more"></a></p></blockquote><h4 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h4><p>用关键字<code>static</code>修饰全局变量，则该变量就被定义成为一个静态全局变量。</p><h4 id="静态全局变量有以下特点："><a href="#静态全局变量有以下特点：" class="headerlink" title="静态全局变量有以下特点："></a>静态全局变量有以下特点：</h4><ul><li>静态全局变量在<strong>全局数据区</strong>分配内存，静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。</li><li>未经初始化的静态全局变量会被程序自动<strong>初始化为0</strong>（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为0）。</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。</li></ul><p>对于一个完整的程序，在内存中的分布情况如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码区    // low address</span><br><span class="line">全局数据区</span><br><span class="line">堆区</span><br><span class="line">栈区      // high address</span><br></pre></td></tr></table></figure><p>一般程序把新产生的动态数据存放在<strong>堆区</strong>。</p><p>函数内部的自动变量存放在<strong>栈区</strong>。<br>自动变量一般会随着函数的退出而释放空间。</p><p>静态数据（即使是函数内部的静态局部变量）也存放在<strong>全局数据区</strong>。<br>全局数据区的数据并不会因为函数的退出而释放空间。</p><h4 id="全局变量和全局静态变量的区别"><a href="#全局变量和全局静态变量的区别" class="headerlink" title="全局变量和全局静态变量的区别"></a>全局变量和全局静态变量的区别</h4><ol><li>全局变量是不显式用<code>static</code>修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过<code>extern</code>全局变量名的声明，就可以使用全局变量。  </li><li>全局静态变量是显式用<code>static</code>修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用<code>extern</code>声明也不能使用。  </li></ol><h4 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h4><p>一般在函数体内定义的个变量，每当程序运行到该语句时都会给该局部变量分配<strong>栈内存</strong>。  </p><p>但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。</p><p>但有时候我们需要在两次调用之间对变量的值进行保存。</p><p>通常的想法是定义一个全局变量来实现。</p><p>但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。  </p><p>静态局部变量正好可以解决这个问题。静态局部变量保存在<strong>全局数据区</strong>，而不是保存在<strong>栈</strong>中，每次的值保持到下一次调用，直到下次赋新值。  </p><h4 id="静态局部变量有以下特点："><a href="#静态局部变量有以下特点：" class="headerlink" title="静态局部变量有以下特点："></a>静态局部变量有以下特点：</h4><ul><li>该变量在<strong>全局数据区</strong>分配内存；</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初<strong>始化为0</strong>；</li><li>它<strong>始终驻留</strong>在全局数据区，直到程序运行结束，<strong>延长了生命周期。</strong><br>但其作用域为<strong>局部作用域</strong>，当定义它的函数或语句块结束时，其作用域随之结束；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;用关键字&lt;code&gt;static&lt;/code&gt;修饰全局变量，则该变量就被定义成为一个静态全局变量。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS 多线程安全问题以及各种锁</title>
    <link href="http://yoursite.com/2019/03/01/iOS%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2019/03/01/iOS 线程同步/</id>
    <published>2019-03-01T06:32:26.875Z</published>
    <updated>2019-03-06T06:58:00.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多线程使用不当会出现资源竞争，比如多个线程同时对一块资源进行修改，就会出现数据错乱的情况。<br><a id="more"></a></p></blockquote><h4 id="多线程安全问题"><a href="#多线程安全问题" class="headerlink" title="多线程安全问题"></a>多线程安全问题</h4><p>多线程使用不当会出现资源竞争，比如多个线程同时对一块资源进行修改，就会出现数据错乱的情况。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> ticketsCount;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ticketTest &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.ticketsCount = <span class="number">15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> quene = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            [<span class="keyword">self</span> saleticket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            [<span class="keyword">self</span> saleticket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            [<span class="keyword">self</span> saleticket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">    sleep(<span class="number">.2</span>);</span><br><span class="line">    oldTicketsCount--;</span><br><span class="line">    <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x600002a06d00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩14张票 - &lt;NSThread: 0x600002a09280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩14张票 - &lt;NSThread: 0x600002a06d80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x600002a09280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x600002a06d00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x600002a06d80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x600002a09280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x600002a06d00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600002a09280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600002a06d80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600002a06d00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600002a06d80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600002a09280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600002a06d00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600002a06d80&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>总票数为15，虽然子线程调用<code>saleticket</code>方法15次，但是打印的数据并没有递减为0。</p><h4 id="线程同步技术"><a href="#线程同步技术" class="headerlink" title="线程同步技术"></a>线程同步技术</h4><p>常见的线程同步技术是<strong>加锁</strong></p><ul><li><p><code>OSSpinLock</code> 自旋锁<br>导入头文件<code>#import &lt;libkern/OSAtomic.h&gt;</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">static</span> OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line">      <span class="comment">// 加锁</span></span><br><span class="line">      OSSpinLockLock(&amp;lock);</span><br><span class="line">      <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">      sleep(<span class="number">.2</span>);</span><br><span class="line">      oldTicketsCount--;</span><br><span class="line">      <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      <span class="comment">// 解锁</span></span><br><span class="line">      OSSpinLockUnlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩3张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩2张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩1张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩0张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>自旋锁等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源。<br>并且现在已经不安全，可能出现优先级反转的问题。<br>如果等待锁的优先级较高，它会一直占用着CPU的资源，优先级低的线程就无法释放锁。<br><strong>在iOS10被苹果废弃。</strong></p></li><li><p><code>os_unfair_lock</code><br>导入头文件<code>#import &lt;os/lock.h&gt;</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) os_unfair_lock lock;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">       <span class="comment">// 初始化</span></span><br><span class="line">       <span class="keyword">self</span>.lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 加锁</span></span><br><span class="line">      os_unfair_lock_lock(&amp;lock);</span><br><span class="line">      <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">      sleep(<span class="number">.2</span>);</span><br><span class="line">      oldTicketsCount--;</span><br><span class="line">      <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      <span class="comment">// 解锁</span></span><br><span class="line">      os_unfair_lock_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩3张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩2张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩1张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩0张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure><p><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code>。<br>等待<code>os_unfair_lock</code>锁的线程处于休眠状态，不是忙等状态。<br><strong>在iOS10开始使用。</strong></p></li><li><p><code>pthread_mutex</code> 互斥锁  </p><p><strong>普通用法</strong></p><p>导入头文件<code>#import &lt;pthread.h&gt;</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_mutex_t mutex;</span><br><span class="line">  </span><br><span class="line">  - (<span class="keyword">void</span>)__initMutex:(pthread_mutex_t *)mutex &#123;</span><br><span class="line"><span class="comment">//    // 初始化属性</span></span><br><span class="line"><span class="comment">//    pthread_mutexattr_t attr;</span></span><br><span class="line"><span class="comment">//    pthread_mutexattr_init(&amp;attr);</span></span><br><span class="line"><span class="comment">//    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span></span><br><span class="line"><span class="comment">//    // 初始化锁</span></span><br><span class="line"><span class="comment">//    pthread_mutex_init(mutex, &amp;attr);</span></span><br><span class="line"><span class="comment">//    // 销毁属性</span></span><br><span class="line"><span class="comment">//    pthread_mutexattr_destroy(&amp;attr);</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 初始化锁 NULL等同于PTHREAD_MUTEX_DEFAULT</span></span><br><span class="line">       pthread_mutex_init(mutex, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        [<span class="keyword">self</span> __initMutex:&amp;_mutex];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">       pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">       <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">       sleep(<span class="number">.2</span>);</span><br><span class="line">       oldTicketsCount--;</span><br><span class="line">       <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">       <span class="comment">// 解锁</span></span><br><span class="line">       pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩3张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩2张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩1张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩0张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure><p><code>mutex</code>也叫“互斥锁”，等待锁的线程处于休眠状态，不是忙等状态。  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mutex type attributes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#define PTHREAD_MUTEX_NORMAL   0  // 正常类型</span></span><br><span class="line"> <span class="meta">#define PTHREAD_MUTEX_ERRORCHECK   1  // 错误检查</span></span><br><span class="line"> <span class="meta">#define PTHREAD_MUTEX_RECURSIVE   2  // 递归类型</span></span><br><span class="line"> <span class="meta">#define PTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_NORMAL</span></span><br></pre></td></tr></table></figure><p>  上面使用的是Normal类型同<code>OSSpinLock</code>和<code>os_unfair_lock</code>作用一样  </p><p>  <strong>递归用法</strong><br>  递归锁在被同一线程重复获取时不会产生死锁<br>  递归类型<code>PTHREAD_MUTEX_RECURSIVE</code>：</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)__initMutex:(pthread_mutex_t *)mutex</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 递归锁：允许同一个线程对一把锁进行重复加锁</span></span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 初始化属性</span></span><br><span class="line">      pthread_mutexattr_t attr;</span><br><span class="line">      pthread_mutexattr_init(&amp;attr);</span><br><span class="line">      pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">      <span class="comment">// 初始化锁</span></span><br><span class="line">      pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line">      <span class="comment">// 销毁属性</span></span><br><span class="line">      pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">         [<span class="keyword">self</span> __initMutex:&amp;_mutex];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">线程1：otherTest（+-）</span></span><br><span class="line"><span class="comment">       otherTest（+-）</span></span><br><span class="line"><span class="comment">         otherTest（+-）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">线程2：otherTest（等待）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">      pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">   </span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">         count++;</span><br><span class="line">         [<span class="keyword">self</span> otherTest];</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">      pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>条件用法</strong>  </p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_mutex_t mutex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_cond_t cond;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *data;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">         <span class="comment">// 初始化属性</span></span><br><span class="line">         pthread_mutexattr_t attr;</span><br><span class="line">         pthread_mutexattr_init(&amp;attr);</span><br><span class="line">         pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">         <span class="comment">// 初始化锁</span></span><br><span class="line">         pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">         <span class="comment">// 销毁属性</span></span><br><span class="line">         pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">       </span><br><span class="line">         <span class="comment">// 初始化条件</span></span><br><span class="line">         pthread_cond_init(&amp;_cond, <span class="literal">NULL</span>);</span><br><span class="line">       </span><br><span class="line">         <span class="keyword">self</span>.data = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">      [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__remove) object:<span class="literal">nil</span>] start];</span><br><span class="line">   </span><br><span class="line">      [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__add) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="comment">// 删除数组中的元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__remove</span><br><span class="line">&#123;</span><br><span class="line">      pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"__remove - begin"</span>);</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>.data.count == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 等待 先解锁进入等待状态</span></span><br><span class="line">         <span class="comment">// 接收到条件信号后，先加锁执行下面的代码，在解锁</span></span><br><span class="line">         pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      [<span class="keyword">self</span>.data removeLastObject];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"删除了元素"</span>);</span><br><span class="line">   </span><br><span class="line">      pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="comment">// 往数组中添加元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__add</span><br><span class="line">&#123;</span><br><span class="line">      pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">   </span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">      [<span class="keyword">self</span>.data addObject:<span class="string">@"Test"</span>];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"添加了元素"</span>);</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 信号</span></span><br><span class="line">      pthread_cond_signal(&amp;_cond);</span><br><span class="line">      <span class="comment">// 广播</span></span><br><span class="line">  <span class="comment">//    pthread_cond_broadcast(&amp;_cond);</span></span><br><span class="line">   </span><br><span class="line">      pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">      pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">      pthread_cond_destroy(&amp;_cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>NSLock、NSRecursiveLock</code><br><code>NSLock</code>是对<code>mutex</code>普通锁的封装<br><code>NSRecursiveLock</code>是对<code>mutex</code>递归锁的封装</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSLock</span> *lock;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">       <span class="comment">// 初始化</span></span><br><span class="line">       <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 加锁</span></span><br><span class="line">      [<span class="keyword">self</span>.lock lock];</span><br><span class="line">      <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">      sleep(<span class="number">.2</span>);</span><br><span class="line">      oldTicketsCount--;</span><br><span class="line">      <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      <span class="comment">// 解锁</span></span><br><span class="line">      [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩3张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩2张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩1张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩0张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure><p><code>NSRecursiveLock</code>用法与<code>NSLock</code>的用法一样。</p></li><li><p><code>NSCondition</code><br><code>NSCondition</code>是对mutex和cond的封装</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSCondition</span> *condition;</span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *data;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">         <span class="keyword">self</span>.condition = [[<span class="built_in">NSCondition</span> alloc] init];</span><br><span class="line">         <span class="keyword">self</span>.data = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">      [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__remove) object:<span class="literal">nil</span>] start];</span><br><span class="line">   </span><br><span class="line">      [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__add) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者-消费者模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="comment">// 删除数组中的元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__remove</span><br><span class="line">&#123;</span><br><span class="line">      [<span class="keyword">self</span>.condition lock];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"__remove - begin"</span>);</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>.data.count == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 等待</span></span><br><span class="line">          [<span class="keyword">self</span>.condition wait];</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      [<span class="keyword">self</span>.data removeLastObject];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"删除了元素"</span>);</span><br><span class="line">   </span><br><span class="line">      [<span class="keyword">self</span>.condition unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="comment">// 往数组中添加元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__add</span><br><span class="line">&#123;</span><br><span class="line">      [<span class="keyword">self</span>.condition lock];</span><br><span class="line">   </span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">      [<span class="keyword">self</span>.data addObject:<span class="string">@"Test"</span>];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"添加了元素"</span>);</span><br><span class="line">      <span class="comment">// 信号</span></span><br><span class="line">      [<span class="keyword">self</span>.condition signal];</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 广播</span></span><br><span class="line">   <span class="comment">//    [self.condition broadcast];</span></span><br><span class="line">      [<span class="keyword">self</span>.condition unlock];</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>NSConditionLock</code><br>它是对<code>NSCondition</code>的进一步封装，可以设置具体的条件值</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSConditionLock</span> *conditionLock;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 初始化的时候 设置条件为1</span></span><br><span class="line">      <span class="keyword">self</span>.conditionLock = [[<span class="built_in">NSConditionLock</span> alloc] initWithCondition:<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__one) object:<span class="literal">nil</span>] start];</span><br><span class="line">  </span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__two) object:<span class="literal">nil</span>] start];</span><br><span class="line">  </span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__three) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__one</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 加锁</span></span><br><span class="line">    [<span class="keyword">self</span>.conditionLock lock];</span><br><span class="line">  </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"__one"</span>);</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 解锁时设置锁的条件为2</span></span><br><span class="line">     [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__two</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当条件为2时 加锁</span></span><br><span class="line">    [<span class="keyword">self</span>.conditionLock lockWhenCondition:<span class="number">2</span>];</span><br><span class="line">  </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"__two"</span>);</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 解锁时设置锁的条件为3</span></span><br><span class="line">     [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__three</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当条件为3时 加锁</span></span><br><span class="line">    [<span class="keyword">self</span>.conditionLock lockWhenCondition:<span class="number">3</span>];</span><br><span class="line">  </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"__three"</span>);</span><br><span class="line">     <span class="comment">// 解锁</span></span><br><span class="line">     [<span class="keyword">self</span>.conditionLock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>dispatch_queue</code><br>  直接使用GCD的串行队列，也可以实现线程同步</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">self</span>.queue = dispatch_queue_create(<span class="string">"queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.moneyQueue, ^&#123;</span><br><span class="line">         <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">         sleep(<span class="number">.2</span>);</span><br><span class="line">         oldTicketsCount--;</span><br><span class="line">         <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩3张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩2张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩1张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩0张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>dispatch_semaphore</code><br>信号量的初始值可以控制线程并发访问的最大值<br>初始值为1时，代表同时只允许1条线程访问资源，保证线程的同步</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) dispatch_semaphore_t semaphore;</span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) dispatch_semaphore_t ticketSemaphore;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">          <span class="comment">// 初始化</span></span><br><span class="line">          <span class="keyword">self</span>.semaphore = dispatch_semaphore_create(<span class="number">5</span>); </span><br><span class="line">          <span class="keyword">self</span>.ticketSemaphore = dispatch_semaphore_create(<span class="number">1</span>);  </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line">      <span class="comment">// 让信号量的值-1 为0 则等待，相当于加锁</span></span><br><span class="line">      dispatch_semaphore_wait(<span class="keyword">self</span>.ticketSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">      <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">    sleep(<span class="number">.2</span>);</span><br><span class="line">    oldTicketsCount--;</span><br><span class="line">    <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      <span class="comment">// 让信号量的值+1，相当于解锁</span></span><br><span class="line">      dispatch_semaphore_signal(<span class="keyword">self</span>.ticketSemaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">          [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) object:<span class="literal">nil</span>] start];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的最大并发数为 5</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 如果信号量的值 &gt; 0，就让信号量的值减1，然后继续往下执行代码</span></span><br><span class="line">      <span class="comment">// 如果信号量的值 &lt;= 0，就会休眠等待，直到信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码</span></span><br><span class="line">      dispatch_semaphore_wait(<span class="keyword">self</span>.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">   </span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"test - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 让信号量的值+1</span></span><br><span class="line">      dispatch_semaphore_signal(<span class="keyword">self</span>.semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  调用otherTest会发现每隔两秒打印5条信息。</p></li><li><p><code>@synchronized</code><br>  是对mutex的递归锁的封装，源码<code>objc4</code>中的<code>objc-sync.mm</code>文件查看<br>  <code>@synchronized(obj)</code>内部会生成<code>obj</code>对应的递归锁，然后进行加锁解锁操作</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line">   <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; <span class="comment">// objc_sync_enter</span></span><br><span class="line">        <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">        sleep(<span class="number">.2</span>);</span><br><span class="line">        oldTicketsCount--;</span><br><span class="line">        <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">     &#125; <span class="comment">// objc_sync_exit</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;多线程使用不当会出现资源竞争，比如多个线程同时对一块资源进行修改，就会出现数据错乱的情况。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="线程同步" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>iOS 一道面试题</title>
    <link href="http://yoursite.com/2019/02/28/iOS%20%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/28/iOS 一道面试题/</id>
    <published>2019-02-28T03:04:23.474Z</published>
    <updated>2019-02-28T03:04:36.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>iOS 一道面试题<br><a id="more"></a></p></blockquote><h3 id="写出以下代码的打印结果"><a href="#写出以下代码的打印结果" class="headerlink" title="写出以下代码的打印结果"></a>写出以下代码的打印结果</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">.0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：<strong>1 3</strong></p><p><code>[self performSelector:@selector(test) withObject:nil afterDelay:.0];</code><br>这句代码的本质是往<code>Runloop</code>中添加定时器，但是子线程的<code>Runloop</code>默认是未启动的。</p><h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">.0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</code>启动<code>Runloop</code>后  </p><p>打印结果 <strong>1 3 2</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS 一道面试题&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>定制个性化 Xcode Templates</title>
    <link href="http://yoursite.com/2019/01/07/%E5%AE%9A%E5%88%B6%E4%B8%AA%E6%80%A7%E5%8C%96%20Xcode%20Templates/"/>
    <id>http://yoursite.com/2019/01/07/定制个性化 Xcode Templates/</id>
    <published>2019-01-07T07:27:58.961Z</published>
    <updated>2019-01-07T07:27:58.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当我们用Xcode的默认模板创建一个empty Swift文件的时候，在文件的顶部会带有一部分注释信息，例如文件名称等，还会默认import Foundation。其实我们如果不想显示这信息可以自己定制模板。<br><a id="more"></a></p></blockquote><p>Xcode为我们提供丰富的模板，如图：</p><p><img src="http://wx1.sinaimg.cn/mw690/006zcW7Ely1fyxv6o3ch3j314k0t87em.jpg" alt=""></p><p>使用默认模板创建一个<code>empty Swift</code>文件时，在顶部会包含一些原始数据和一个<code>import</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HQTest.swift</span></span><br><span class="line"><span class="comment">//  test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by gandijun on 2019/1/7.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HeQing. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br></pre></td></tr></table></figure><p>如果我们想每次创建文件的时候，删除这些信息，并且不每次手动删除，就需要定制个性化的模板。</p><h3 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h3><p>为了创建我们自己的模板，我们可以copy一个系统的模板，然后把它顶部的存在的代码删掉。</p><p>Xcode查找自定义模板的路径：<code>~/Library/Developer/Xcode/Templates</code>。<br>这里的文件夹在Xcode中打开时会被当成组。我们将创建一个名为<code>Custom</code>的组并且把系统自带的<code>Swift template</code>拷贝进去。</p><p>在终端中执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/Library/Developer/Xcode/Templates/Custom</span><br><span class="line">$ cp -R /Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File\ Templates/Source/Swift\ File.xctemplate ~/Library/Developer/Xcode/Templates/Custom/</span><br></pre></td></tr></table></figure><p>模板拷贝完成，我们<code>cd</code>进去看看都有什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/Library/Developer/Xcode/Templates/Custom/Swift\ File.xctemplate</span><br><span class="line">$ ls</span><br><span class="line">TemplateIcon.png          TemplateIcon@2x.png       TemplateInfo.plist        ___FILEBASENAME___.swift</span><br></pre></td></tr></table></figure><p>这里面有一些icons，一个plist文件和一个Swift的文件。打开这个swift文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat ___FILEBASENAME___.swift</span><br><span class="line">//___FILEHEADER___</span><br><span class="line"></span><br><span class="line">import Foundation</span><br></pre></td></tr></table></figure><p>这个就是系统的<code>empty swift</code>模板。<br>通过编辑器删除里面的内容，或者通过终端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm ___FILEBASENAME___.swift</span><br><span class="line">$ touch ___FILEBASENAME___.swift</span><br></pre></td></tr></table></figure><p>到这里就完成了。<br>打开Xcode创建一个新的Swift文件，选择Custom组里面的模板。<br>你会发现创建的文件的顶部的代码消失了！</p><p><img src="http://wx1.sinaimg.cn/mw690/006zcW7Ely1fyy1ux4p8dj314k0t848d.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当我们用Xcode的默认模板创建一个empty Swift文件的时候，在文件的顶部会带有一部分注释信息，例如文件名称等，还会默认import Foundation。其实我们如果不想显示这信息可以自己定制模板。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift 捕获列表Capture List</title>
    <link href="http://yoursite.com/2019/01/04/Swift%20%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8Capture%20List/"/>
    <id>http://yoursite.com/2019/01/04/Swift 捕获列表Capture List/</id>
    <published>2019-01-04T08:46:46.104Z</published>
    <updated>2019-01-04T08:46:46.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们都知道swift闭包捕获的是引用，但是swift闭包任何时候都是捕获变量的引用吗？并不是！<br><a id="more"></a></p></blockquote><h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><p>在使用<code>Swift</code>编写程序时经常使用闭包，我们都知道<code>swift</code>闭包捕获的是引用，但是<code>swift</code>闭包任何时候都是捕获变量的引用吗？并不是！有时会使用到<strong>捕获列表</strong>，我们经常使用[weak self]来防止内存泄漏。</p><p>我们来看一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> closure : () -&gt; () = &#123; <span class="built_in">print</span>(a, b) &#125;</span><br></pre></td></tr></table></figure><p>执行闭包</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closure()   <span class="comment">// 0 0</span></span><br></pre></td></tr></table></figure><p>改变a,b的值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>再次调用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closure()  <span class="comment">// 3 7</span></span><br></pre></td></tr></table></figure><p>我们可以很直观的看到现在的a,b值都改变了。<code>swift</code>的闭包中捕获到的值是捕获的引用。所以一旦你改变了这些捕获变量的值，在闭包中就会反应出来。</p><h3 id="引用类型会带来一些问题"><a href="#引用类型会带来一些问题" class="headerlink" title="引用类型会带来一些问题"></a>引用类型会带来一些问题</h3><p>很多时候，闭包的特性并不总是那么直观，很容易带来一些奇怪的错误。比如，我们创建一个<code>Array</code>，然后数组的类型是闭包</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayClosure :  [() -&gt; ()] = []</span><br></pre></td></tr></table></figure><p>执行下面的代码，将闭包添加到数组中</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> &#123;  </span><br><span class="line">    arrayClosure.append &#123; <span class="built_in">print</span>(i) &#125;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条用数组中的三个闭包看看打印值:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayClosure[<span class="number">0</span>]()<span class="comment">// 3</span></span><br><span class="line">arrayClosure[<span class="number">1</span>]()<span class="comment">// 3</span></span><br><span class="line">arrayClosure[<span class="number">2</span>]()<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>闭包打印的值都是最后一次的值。因为闭包捕获的是<strong>i</strong>的引用。如果想打印出1，2，3就要捕获到i的值。这时候就需要用到<strong>捕获列表</strong>了。</p><p>再看下面的例子，我们加了<code>[c, d] in</code> ，关键字 <code>in</code> 的左边就是我们的重点，这里表示的不是数组，而是<strong>捕获列表</strong>。一旦用了<strong>捕获列表</strong>，闭包捕获的将不是原始值的引用，而是在闭包内生成了一个原始值的copy副本。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherClosure : () -&gt; () = &#123;  [<span class="built_in">c</span>, d]  <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">c</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">c</span> = <span class="number">3</span></span><br><span class="line">d = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>调用闭包</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anotherClosure() <span class="comment">// 0, 0</span></span><br></pre></td></tr></table></figure><p>例子2修改打印1，2，3</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> &#123;  </span><br><span class="line">    arrayClosure.append &#123; [i] <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(i) </span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条用数组中的三个闭包看看打印值:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayClosure[<span class="number">0</span>]()<span class="comment">// 1</span></span><br><span class="line">arrayClosure[<span class="number">1</span>]()<span class="comment">// 2</span></span><br><span class="line">arrayClosure[<span class="number">2</span>]()<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们都知道swift闭包捕获的是引用，但是swift闭包任何时候都是捕获变量的引用吗？并不是！&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="Capture List" scheme="http://yoursite.com/tags/Capture-List/"/>
    
  </entry>
  
  <entry>
    <title>Tap手势和UITableView点击冲突问题</title>
    <link href="http://yoursite.com/2018/12/29/Tap%E6%89%8B%E5%8A%BF%E5%92%8CUITableView%E7%82%B9%E5%87%BB%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/12/29/Tap手势和UITableView点击冲突问题/</id>
    <published>2018-12-29T03:32:37.792Z</published>
    <updated>2018-12-29T03:40:19.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过UIGestureRecognizerDelegate解决<br><a id="more"></a></p></blockquote><h3 id="方案代码"><a href="#方案代码" class="headerlink" title="方案代码"></a>方案代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gestureRecognizer</span><span class="params">(<span class="number">_</span> gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> point = touch.location(<span class="keyword">in</span>: referenceView)</span><br><span class="line">    <span class="comment">//注意：touchView应该是referenceView的子视图</span></span><br><span class="line">    <span class="keyword">if</span> touchView.frame.<span class="built_in">contains</span>(point) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;     <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过UIGestureRecognizerDelegate解决&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="iOS开发Tips" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91Tips/"/>
    
  </entry>
  
  <entry>
    <title>Charles抓包 http、https</title>
    <link href="http://yoursite.com/2018/12/29/Charles%E6%8A%93%E5%8C%85%20http%E3%80%81https/"/>
    <id>http://yoursite.com/2018/12/29/Charles抓包 http、https/</id>
    <published>2018-12-29T03:32:37.792Z</published>
    <updated>2019-02-28T03:17:16.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Charles抓包 http、https步骤详情记录<br><a id="more"></a></p></blockquote><h3 id="抓取http"><a href="#抓取http" class="headerlink" title="抓取http"></a>抓取http</h3><ol><li><p>打开Charles</p></li><li><p>查找电脑端ip</p><p> <img src="https://img-blog.csdnimg.cn/20190221170949452.png" alt="在这里插入图片描述"></p></li><li><p>手机端同一局域网下手动配置代理       </p><p> <img src="https://img-blog.csdnimg.cn/2019022117161879.PNG" alt="在这里插入图片描述"></p></li><li><p>手机打开任意APP请求网络，Charles会弹出确认窗口，点击同意后，可以开始抓包操作。</p></li></ol><h3 id="抓取https"><a href="#抓取https" class="headerlink" title="抓取https"></a>抓取https</h3><ol><li><p>点击Charles Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device</p><p> <img src="https://img-blog.csdnimg.cn/2019022117243467.png" alt="在这里插入图片描述"></p></li><li><p>弹出如下框</p><p> <img src="https://img-blog.csdnimg.cn/2019022117264757.png" alt="在这里插入图片描述"></p><p>在手机<code>Safari</code>浏览器输入地址 <code>chls.pro/ssl</code>，出现证书安装页面，点击安装<br>手机设置有密码的输入密码进行安装<br>如下图安装完成<br>(如果抓取Mac端数据，则在Mac的<code>Safari</code>浏览器输入地址 <code>chls.pro/ssl</code>，下载证书双击安装后在钥匙串中找到设置信任即可)</p><p> <img src="https://img-blog.csdnimg.cn/20190221172819533.jpg" alt="在这里插入图片描述"></p></li><li><p>设置-&gt;通用-&gt;关于本机-&gt;证书信任设置<br> 信任刚才的证书</p><p> <img src="https://img-blog.csdnimg.cn/20190221173046838.jpg" alt="在这里插入图片描述"></p></li><li><p>配置Charles Proxy<br> Proxy -&gt; SSL Proxying Settings</p><p> <img src="https://img-blog.csdnimg.cn/20190222084312438.png" alt="在这里插入图片描述"></p><p> 勾选Enable SSL Proxying，点击Add</p><p> <img src="https://img-blog.csdnimg.cn/20190222084527545.png" alt="在这里插入图片描述"></p><p> 填写信息，点击确认OK后，即可抓取此域名下的数据。</p><p> <img src="https://img-blog.csdnimg.cn/20190222085743582.png" alt="在这里插入图片描述"></p><p> 抓取测试</p><p> <img src="https://img-blog.csdnimg.cn/20190222085753917.png" alt="在这里插入图片描述"></p></li></ol><p>Charles注册码，感谢分享<br>Registered Name: <a href="https://zhile.io" target="_blank" rel="noopener">https://zhile.io</a><br>License Key: 48891cf209c6d32bf4<br>4.2.7版本亲测可用</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Charles抓包 http、https步骤详情记录&lt;br&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Charles" scheme="http://yoursite.com/tags/Charles/"/>
    
  </entry>
  
</feed>
