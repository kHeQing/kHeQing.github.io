<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeQing</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-25T02:23:46.243Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HeQing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS Tagged Pointer</title>
    <link href="http://yoursite.com/2019/03/25/iOS%20Tagged%20Pointer/"/>
    <id>http://yoursite.com/2019/03/25/iOS Tagged Pointer/</id>
    <published>2019-03-25T02:23:46.243Z</published>
    <updated>2019-03-25T02:23:46.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。<br><a id="more"></a></p></blockquote><h4 id="iOS程序的内存布局"><a href="#iOS程序的内存布局" class="headerlink" title="iOS程序的内存布局"></a>iOS程序的内存布局</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">保留  低</span><br><span class="line">-------------</span><br><span class="line">代码区（__TEXT）</span><br><span class="line">-------------</span><br><span class="line">数据区（__DATA）</span><br><span class="line">  字符串常量</span><br><span class="line">  已初始化的数据</span><br><span class="line">  未初始化的数据</span><br><span class="line">-------------</span><br><span class="line">堆（heap）↓</span><br><span class="line">-------------</span><br><span class="line">栈（stack)↑</span><br><span class="line">-------------</span><br><span class="line">内核区高</span><br></pre></td></tr></table></figure><ul><li>代码区：编译之后的代码</li><li>数据段<ul><li>字符串常量：比如<code>NSString *str = @&quot;123&quot;</code></li><li>已初始化数据：已初始化的全局变量、静态变量等</li><li>未初始化数据：未初始化的全局变量、静态变量等</li></ul></li><li>栈：函数调用开销，比如局部变量。分配的内存空间地址越来越小</li><li>堆：通过alloc、malloc、calloc等动态分配的空间，分配的内存空间地址越来越大</li></ul><h4 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h4><ul><li><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储。</p></li><li><p>在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值。</p></li><li><p>使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。</p></li><li><p>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据。</p></li><li><p><code>objc_msgSend</code>能识别<code>Tagged Pointer</code>，比如<code>NSNumber</code>的<code>intValue</code>方法，直接从指针提取数据，节省了以前的调用开销。</p></li><li><p>如何判断一个指针是否为Tagged Pointer？  </p><ul><li>iOS平台，最高有效位是1（第64bit）  </li><li>Mac平台，最低有效位是1</li></ul></li></ul><h4 id="判断是否为Tagged-Pointer"><a href="#判断是否为Tagged-Pointer" class="headerlink" title="判断是否为Tagged Pointer"></a>判断是否为Tagged Pointer</h4><p>在OC源码中发现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   define _OBJC_TAG_MASK (1UL<span class="meta-string">&lt;&lt;63)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#else</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define _OBJC_TAG_MASK 1UL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#endif</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">static inline bool </span></span></span><br><span class="line"><span class="meta"><span class="meta-string">_objc_isTaggedPointer(const void * _Nullable ptr) </span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h4><p>以下两段代码会发生什么事？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abcdefghijk"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abc"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一段代码会崩溃，<code>Thread 3: EXC_BAD_ACCESS (code=1, address=0x14a99517b500)</code>。  </p><p>因为第一段代码字符串比较长，所以存储的对象方式。<br>调用set方法赋值，最终会走下面的代码，（arc底层也会转成mrc方式）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_name != name) &#123;</span><br><span class="line">        [_name release];</span><br><span class="line">        _name = [name <span class="keyword">retain</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看出<code>[_name release]</code>可能会多次释放，造成坏内存访问。</p><p>解决方法<code>@property (strong, nonatomic) NSString *name;</code></p><ul><li><code>nonatomic</code>改成<code>atomic</code></li><li>加锁<code>self.name = [NSString stringWithFormat:@&quot;abcdefghijk&quot;];</code></li></ul><p>第二段代码正常运行。</p><p>因为第二段的字符串比较短，存储方式为<code>Tagged Pointer</code>，不走set方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 232 用栈实现队列</title>
    <link href="http://yoursite.com/2019/03/18/LeetCode%20232%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/03/18/LeetCode 232 用栈实现队列/</id>
    <published>2019-03-18T02:53:54.498Z</published>
    <updated>2019-03-18T02:53:54.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LeetCode 232 用栈实现队列<br><a id="more"></a></p></blockquote><h4 id="LeetCode-232-用栈实现队列"><a href="#LeetCode-232-用栈实现队列" class="headerlink" title="LeetCode 232 用栈实现队列"></a>LeetCode 232 用栈实现队列</h4><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。  </p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // 返回 1</span><br><span class="line">queue.pop();   // 返回 1</span><br><span class="line">queue.empty(); // 返回 false</span><br></pre></td></tr></table></figure><p>说明:</p><p>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</p><h4 id="python解法"><a href="#python解法" class="headerlink" title="python解法"></a>python解法</h4><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>        <span class="string">"""</span><span class="string">        Initialize your data structure here.</span><span class="string">        """</span>        self.inStack, self.outStack = [], []    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span>        <span class="string">"""</span><span class="string">        Push element x to the back of queue.</span><span class="string">        """</span>        self.inStack.append(x)    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span>        <span class="string">"""</span><span class="string">        Removes the element from in front of queue and returns that element.</span><span class="string">        """</span>        self.move()        <span class="keyword">return</span> self.outStack.pop()    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span> -&gt; int:</span>        <span class="string">"""</span><span class="string">        Get the front element.</span><span class="string">        """</span>        self.move()        <span class="keyword">return</span> self.outStack[<span class="number">-1</span>]    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span> -&gt; bool:</span>        <span class="string">"""</span><span class="string">        Returns whether the queue is empty.</span><span class="string">        """</span>        <span class="keyword">return</span> (<span class="keyword">not</span> self.inStack) <span class="keyword">and</span> (<span class="keyword">not</span> self.outStack)    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self)</span>:</span>        <span class="string">"""</span><span class="string">        :rtype nothing</span><span class="string">        """</span>        <span class="keyword">if</span> <span class="keyword">not</span> self.outStack:            <span class="keyword">while</span> self.inStack:                self.outStack.append(self.inStack.pop())</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LeetCode 232 用栈实现队列&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD定时器封装</title>
    <link href="http://yoursite.com/2019/03/18/GCD%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2019/03/18/GCD定时器封装/</id>
    <published>2019-03-18T02:38:21.165Z</published>
    <updated>2019-03-18T02:38:21.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时。<br><a id="more"></a></p></blockquote><h4 id="GCD定时器封装"><a href="#GCD定时器封装" class="headerlink" title="GCD定时器封装"></a>GCD定时器封装</h4><p><code>NSTimer</code>依赖于<code>RunLoop</code>，如果<code>RunLoop</code>的任务过于繁重，可能会导致<code>NSTimer</code>不准时。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HQTimer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTask:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))task</span><br><span class="line">                 start:(<span class="built_in">NSTimeInterval</span>)start</span><br><span class="line">              interval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">               repeats:(<span class="built_in">BOOL</span>)repeats</span><br><span class="line">                 async:(<span class="built_in">BOOL</span>)async;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTask:(<span class="keyword">id</span>)target</span><br><span class="line">              selector:(SEL)selector</span><br><span class="line">                 start:(<span class="built_in">NSTimeInterval</span>)start</span><br><span class="line">              interval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">               repeats:(<span class="built_in">BOOL</span>)repeats</span><br><span class="line">                 async:(<span class="built_in">BOOL</span>)async;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)cancelTask:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HQTimer</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *timers_;</span><br><span class="line">dispatch_semaphore_t semaphore_;</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        timers_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        semaphore_ = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSString</span> *)execTask:(<span class="keyword">id</span>)target selector:(SEL)selector start:(<span class="built_in">NSTimeInterval</span>)start interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats async:(<span class="built_in">BOOL</span>)async &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!target || !selector) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> execTask:^&#123;</span><br><span class="line">        <span class="keyword">if</span> ([target respondsToSelector:selector]) &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">            [target performSelector:selector];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; start:start interval:interval repeats:repeats async:async];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))task start:(<span class="built_in">NSTimeInterval</span>)start interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="built_in">BOOL</span>)repeats async:(<span class="built_in">BOOL</span>)async &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!task || start &lt; <span class="number">0</span> || (interval &lt;= <span class="number">0</span> &amp;&amp; repeats)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = async ? dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>) : dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置时间</span></span><br><span class="line">    dispatch_source_set_timer(timer,</span><br><span class="line">                              dispatch_time(DISPATCH_TIME_NOW, start * <span class="built_in">NSEC_PER_SEC</span>),</span><br><span class="line">                              interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="comment">// 定时器的唯一标识</span></span><br><span class="line">    <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%zd"</span>, timers_.count];</span><br><span class="line">    <span class="comment">// 存放到字典中</span></span><br><span class="line">    timers_[name] = timer;</span><br><span class="line">    dispatch_semaphore_signal(semaphore_);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置回调</span></span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        task();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!repeats) &#123; <span class="comment">// 不重复的任务</span></span><br><span class="line">            [<span class="keyword">self</span> cancelTask:name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)cancelTask:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (name.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t timer = timers_[name];</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timer);</span><br><span class="line">        [timers_ removeObjectForKey:name];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_signal(semaphore_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    [HQTimer execTask:^&#123;</span></span><br><span class="line"><span class="comment">//        NSLog(@"111111---%@",[NSThread currentThread]);</span></span><br><span class="line"><span class="comment">//    &#125; start:2.0 interval:1 repeats:YES async:YES];</span></span><br><span class="line">    </span><br><span class="line">    [HQTimer execTask:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task) start:<span class="number">2</span> interval:<span class="number">1</span> repeats:<span class="literal">YES</span> async:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)task&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"111111---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="GCD定时器" scheme="http://yoursite.com/tags/GCD%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 239 滑动窗口最大值</title>
    <link href="http://yoursite.com/2019/03/15/LeetCode%20239%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2019/03/15/LeetCode 239 滑动窗口最大值/</id>
    <published>2019-03-15T02:59:16.540Z</published>
    <updated>2019-03-18T02:51:38.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LeetCode 239 滑动窗口最大值<br><a id="more"></a></p></blockquote><h4 id="LeetCode-239-滑动窗口最大值"><a href="#LeetCode-239-滑动窗口最大值" class="headerlink" title="LeetCode 239 滑动窗口最大值"></a>LeetCode 239 滑动窗口最大值</h4><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口最大值。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p>注意：</p><p>你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。</p><p>Python解法：<br>双端队列deque</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        res, window = [], []</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            当窗口移动过程中，右侧即将加入新值的时候，判断左侧的值是否需要移除</span></span><br><span class="line"><span class="string">            条件一：i&gt;=k 判断新值的下标是否已经大于窗口（队列）的容量</span></span><br><span class="line"><span class="string">            条件二：window[0] &lt;= i - k 是判断窗口是否是装满的 因为下面会移动过程中可能会把小的元素移除</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k <span class="keyword">and</span> window[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                window.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            即将加入新值时，把窗口里面的存的下标对应的值比新值小的移除</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">while</span> window <span class="keyword">and</span> nums[window[<span class="number">-1</span>]] &lt;= x:</span><br><span class="line">                window.pop()</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            窗口添加新值的下标</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            window.append(i)</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            将最大值添加到结果集中 </span></span><br><span class="line"><span class="string">            i &gt;= k -1 窗口完全滑进数组是开始添加</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k <span class="number">-1</span>:</span><br><span class="line">                res.append(nums[window[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LeetCode 239 滑动窗口最大值&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="双端队列" scheme="http://yoursite.com/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CADisplayLink、NSTimer 循环引用以及解决方法</title>
    <link href="http://yoursite.com/2019/03/13/CADisplayLink%E3%80%81NSTimer%20%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/13/CADisplayLink、NSTimer 循环引用以及解决方法/</id>
    <published>2019-03-13T02:35:26.092Z</published>
    <updated>2019-03-13T02:36:23.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CADisplayLink、NSTimer使用不当会产生循环引用<br><a id="more"></a></p></blockquote><h4 id="CADisplayLink、NSTimer使用不当会产生循环引用"><a href="#CADisplayLink、NSTimer使用不当会产生循环引用" class="headerlink" title="CADisplayLink、NSTimer使用不当会产生循环引用"></a>CADisplayLink、NSTimer使用不当会产生循环引用</h4><p><code>CADisplaylink</code>、<code>NSTimer</code>会对<code>target</code>产生强引用，如果<code>target</code>又对它们产生强引用，那么就会发生循环引用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CADisplayLink</span> *link;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用频率和屏幕的刷帧频率一致，60FPS</span></span><br><span class="line">    <span class="keyword">self</span>.link = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(linkTest)];</span><br><span class="line">    [<span class="keyword">self</span>.link addToRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    __weak typeof(self) weakSelf = self;</span></span><br><span class="line"><span class="comment">//    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span></span><br><span class="line"><span class="comment">//        [weakSelf timerTest];</span></span><br><span class="line"><span class="comment">//    &#125;];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)linkTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    [<span class="keyword">self</span>.link invalidate];</span><br><span class="line"><span class="comment">//    [self.timer invalidate];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>以上代码当控制器销毁的时候，不会走<code>dealloc</code>方法。<code>linkTest</code>方法会一直调用。<br><code>__weak typeof(self) weakSelf = self;</code>的解决方法只适用于<code>block</code>的情况。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用代理对象<code>NSProxy</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSProxy</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Classisa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)alloc;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NSProxy</code>类是与<code>NSObject</code>类同级别的基类。并且<code>NSProxy</code>类没有<code>init</code>方法，只有<code>alloc</code>方法。  </p><p>创建一个代理类继承自<code>NSProxy</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HQProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="comment">// 注意此处是weak修饰target </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HQProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    HQProxy *proxy = [MJProxy alloc]; <span class="comment">// 没有init方法</span></span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取消息签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息转发</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>NSProxy</code>实例对象收到消息首先会在自己的类对象的方法列表中查找有没有对应的方法<br>如果没有会直接进入消息转发转发给它内部的<code>target</code>对象处理，不会再在自己的父类的方法列表中查找<br>这样就提高了效率。</p><p>回到<code>viewcontroller</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向`[HQProxy proxyWithTarget:self]`这个对象发送`timerTest`消息，传过去的`target`是`self`。</span></span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:[HQProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(timerTest) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果不会产生循环引用。控制器销毁会进入<code>dealloc</code>方法。</p><p>流程图如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">C[ViewController targrt] --&gt; A[NSTimer target]</span><br><span class="line">A --&gt; B[NSProxy targrt]</span><br><span class="line">B -.-&gt; C</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;CADisplayLink、NSTimer使用不当会产生循环引用&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="循环引用" scheme="http://yoursite.com/tags/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的读写安全方案</title>
    <link href="http://yoursite.com/2019/03/08/iOS%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E5%AE%89%E5%85%A8%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/03/08/iOS中的读写安全方案/</id>
    <published>2019-03-08T08:51:08.196Z</published>
    <updated>2019-03-11T03:38:00.016Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>iOS中的读写安全方案<br><a id="more"></a></p></blockquote><h4 id="iOS中的读写安全方案"><a href="#iOS中的读写安全方案" class="headerlink" title="iOS中的读写安全方案"></a>iOS中的读写安全方案</h4><ul><li>同一时间，只能有一个线程进行写操作</li><li>同一时间，允许多个线程进行读操作</li><li>同一时间，不允许既有写操作，又有读操作</li></ul><h4 id="方案一：pthread-rwlock读写锁"><a href="#方案一：pthread-rwlock读写锁" class="headerlink" title="方案一：pthread_rwlock读写锁"></a>方案一：<code>pthread_rwlock</code>读写锁</h4><p>导入头文件<code>#import &lt;pthread.h&gt;</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_rwlock_t lock;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> write];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write</span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案二：dispatch-barrier-async异步栅栏函数"><a href="#方案二：dispatch-barrier-async异步栅栏函数" class="headerlink" title="方案二：dispatch_barrier_async异步栅栏函数"></a>方案二：<code>dispatch_barrier_async</code>异步栅栏函数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.queue = dispatch_queue_create(<span class="string">"rw_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        dispatch_barrier_async(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> write];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"read"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write</span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"write"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>dispatch_barrier_async</code>必须使用自己创建的并行队列才有效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS中的读写安全方案&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="读写安全" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS atomic 原子性</title>
    <link href="http://yoursite.com/2019/03/07/iOS%20atomic%20%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <id>http://yoursite.com/2019/03/07/iOS atomic 原子性/</id>
    <published>2019-03-07T01:33:40.062Z</published>
    <updated>2019-03-07T01:51:25.114Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>atomic</code>用于保证属性<code>setter、getter</code>的原子性操作，相当于在<code>getter</code>和<code>setter</code>内部加了线程同步锁<br><a id="more"></a></p></blockquote><h4 id="atomic-原子性"><a href="#atomic-原子性" class="headerlink" title="atomic 原子性"></a>atomic 原子性</h4><p><code>atomic</code>用于保证属性<code>setter、getter</code>的原子性操作，相当于在<code>getter</code>和<code>setter</code>内部加了线程同步锁  </p><p>源码在<code>objc4</code>的<code>objc-accessors.mm</code>里面可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reallySetProperty</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> copy, <span class="keyword">bool</span> mutableCopy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_getProperty</span><span class="params">(id self, SEL _cmd, <span class="keyword">ptrdiff_t</span> offset, BOOL atomic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain release world</span></span><br><span class="line">    id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    id value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它并不能保证使用属性的过程是线程安全的<br>例如属性为一个数组，对数组进行set、get方法的调用是线程安全的<br>但是往数组中添加元素的过程不是线程安全的，需要另外加锁 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="literal">NULL</span>, ^&#123;</span><br><span class="line">        <span class="comment">// 加锁 set</span></span><br><span class="line">        p.data = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 加锁 get   </span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = p.data;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁 添加元素</span></span><br><span class="line">[array addObject:<span class="string">@"1"</span>];</span><br><span class="line">[array addObject:<span class="string">@"2"</span>];</span><br><span class="line">[array addObject:<span class="string">@"3"</span>];</span><br><span class="line"><span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p><code>atomic</code>比较耗费性能，在iOS中使用比较少，在mac编程中使用较多。<br>iOS一般对同一个属性的读写都在同一线程，且操作比较频繁。因此使用<code>nonatomic</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;atomic&lt;/code&gt;用于保证属性&lt;code&gt;setter、getter&lt;/code&gt;的原子性操作，相当于在&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;内部加了线程同步锁&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Static 静态变量</title>
    <link href="http://yoursite.com/2019/03/01/static-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2019/03/01/static-静态变量/</id>
    <published>2019-03-01T08:44:17.342Z</published>
    <updated>2019-03-04T01:31:26.113Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用关键字<code>static</code>修饰全局变量，则该变量就被定义成为一个静态全局变量。<br><a id="more"></a></p></blockquote><h4 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h4><p>用关键字<code>static</code>修饰全局变量，则该变量就被定义成为一个静态全局变量。</p><h4 id="静态全局变量有以下特点："><a href="#静态全局变量有以下特点：" class="headerlink" title="静态全局变量有以下特点："></a>静态全局变量有以下特点：</h4><ul><li>静态全局变量在<strong>全局数据区</strong>分配内存，静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。</li><li>未经初始化的静态全局变量会被程序自动<strong>初始化为0</strong>（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为0）。</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。</li></ul><p>对于一个完整的程序，在内存中的分布情况如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码区    // low address</span><br><span class="line">全局数据区</span><br><span class="line">堆区</span><br><span class="line">栈区      // high address</span><br></pre></td></tr></table></figure><p>一般程序把新产生的动态数据存放在<strong>堆区</strong>。</p><p>函数内部的自动变量存放在<strong>栈区</strong>。<br>自动变量一般会随着函数的退出而释放空间。</p><p>静态数据（即使是函数内部的静态局部变量）也存放在<strong>全局数据区</strong>。<br>全局数据区的数据并不会因为函数的退出而释放空间。</p><h4 id="全局变量和全局静态变量的区别"><a href="#全局变量和全局静态变量的区别" class="headerlink" title="全局变量和全局静态变量的区别"></a>全局变量和全局静态变量的区别</h4><ol><li>全局变量是不显式用<code>static</code>修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过<code>extern</code>全局变量名的声明，就可以使用全局变量。  </li><li>全局静态变量是显式用<code>static</code>修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用<code>extern</code>声明也不能使用。  </li></ol><h4 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h4><p>一般在函数体内定义的个变量，每当程序运行到该语句时都会给该局部变量分配<strong>栈内存</strong>。  </p><p>但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。</p><p>但有时候我们需要在两次调用之间对变量的值进行保存。</p><p>通常的想法是定义一个全局变量来实现。</p><p>但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。  </p><p>静态局部变量正好可以解决这个问题。静态局部变量保存在<strong>全局数据区</strong>，而不是保存在<strong>栈</strong>中，每次的值保持到下一次调用，直到下次赋新值。  </p><h4 id="静态局部变量有以下特点："><a href="#静态局部变量有以下特点：" class="headerlink" title="静态局部变量有以下特点："></a>静态局部变量有以下特点：</h4><ul><li>该变量在<strong>全局数据区</strong>分配内存；</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初<strong>始化为0</strong>；</li><li>它<strong>始终驻留</strong>在全局数据区，直到程序运行结束，<strong>延长了生命周期。</strong><br>但其作用域为<strong>局部作用域</strong>，当定义它的函数或语句块结束时，其作用域随之结束；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;用关键字&lt;code&gt;static&lt;/code&gt;修饰全局变量，则该变量就被定义成为一个静态全局变量。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS 多线程安全问题以及各种锁</title>
    <link href="http://yoursite.com/2019/03/01/iOS%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2019/03/01/iOS 线程同步/</id>
    <published>2019-03-01T06:32:26.875Z</published>
    <updated>2019-03-06T06:58:00.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多线程使用不当会出现资源竞争，比如多个线程同时对一块资源进行修改，就会出现数据错乱的情况。<br><a id="more"></a></p></blockquote><h4 id="多线程安全问题"><a href="#多线程安全问题" class="headerlink" title="多线程安全问题"></a>多线程安全问题</h4><p>多线程使用不当会出现资源竞争，比如多个线程同时对一块资源进行修改，就会出现数据错乱的情况。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> ticketsCount;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ticketTest &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.ticketsCount = <span class="number">15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> quene = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            [<span class="keyword">self</span> saleticket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            [<span class="keyword">self</span> saleticket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            [<span class="keyword">self</span> saleticket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">    sleep(<span class="number">.2</span>);</span><br><span class="line">    oldTicketsCount--;</span><br><span class="line">    <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x600002a06d00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩14张票 - &lt;NSThread: 0x600002a09280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩14张票 - &lt;NSThread: 0x600002a06d80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x600002a09280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x600002a06d00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x600002a06d80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x600002a09280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x600002a06d00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600002a09280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600002a06d80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600002a06d00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600002a06d80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600002a09280&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600002a06d00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600002a06d80&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>总票数为15，虽然子线程调用<code>saleticket</code>方法15次，但是打印的数据并没有递减为0。</p><h4 id="线程同步技术"><a href="#线程同步技术" class="headerlink" title="线程同步技术"></a>线程同步技术</h4><p>常见的线程同步技术是<strong>加锁</strong></p><ul><li><p><code>OSSpinLock</code> 自旋锁<br>导入头文件<code>#import &lt;libkern/OSAtomic.h&gt;</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">static</span> OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line">      <span class="comment">// 加锁</span></span><br><span class="line">      OSSpinLockLock(&amp;lock);</span><br><span class="line">      <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">      sleep(<span class="number">.2</span>);</span><br><span class="line">      oldTicketsCount--;</span><br><span class="line">      <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      <span class="comment">// 解锁</span></span><br><span class="line">      OSSpinLockUnlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩3张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩2张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩1张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩0张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>自旋锁等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源。<br>并且现在已经不安全，可能出现优先级反转的问题。<br>如果等待锁的优先级较高，它会一直占用着CPU的资源，优先级低的线程就无法释放锁。<br><strong>在iOS10被苹果废弃。</strong></p></li><li><p><code>os_unfair_lock</code><br>导入头文件<code>#import &lt;os/lock.h&gt;</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) os_unfair_lock lock;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">       <span class="comment">// 初始化</span></span><br><span class="line">       <span class="keyword">self</span>.lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 加锁</span></span><br><span class="line">      os_unfair_lock_lock(&amp;lock);</span><br><span class="line">      <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">      sleep(<span class="number">.2</span>);</span><br><span class="line">      oldTicketsCount--;</span><br><span class="line">      <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      <span class="comment">// 解锁</span></span><br><span class="line">      os_unfair_lock_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩3张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩2张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩1张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩0张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure><p><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code>。<br>等待<code>os_unfair_lock</code>锁的线程处于休眠状态，不是忙等状态。<br><strong>在iOS10开始使用。</strong></p></li><li><p><code>pthread_mutex</code> 互斥锁  </p><p><strong>普通用法</strong></p><p>导入头文件<code>#import &lt;pthread.h&gt;</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_mutex_t mutex;</span><br><span class="line">  </span><br><span class="line">  - (<span class="keyword">void</span>)__initMutex:(pthread_mutex_t *)mutex &#123;</span><br><span class="line"><span class="comment">//    // 初始化属性</span></span><br><span class="line"><span class="comment">//    pthread_mutexattr_t attr;</span></span><br><span class="line"><span class="comment">//    pthread_mutexattr_init(&amp;attr);</span></span><br><span class="line"><span class="comment">//    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span></span><br><span class="line"><span class="comment">//    // 初始化锁</span></span><br><span class="line"><span class="comment">//    pthread_mutex_init(mutex, &amp;attr);</span></span><br><span class="line"><span class="comment">//    // 销毁属性</span></span><br><span class="line"><span class="comment">//    pthread_mutexattr_destroy(&amp;attr);</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 初始化锁 NULL等同于PTHREAD_MUTEX_DEFAULT</span></span><br><span class="line">       pthread_mutex_init(mutex, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        [<span class="keyword">self</span> __initMutex:&amp;_mutex];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">       pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">       <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">       sleep(<span class="number">.2</span>);</span><br><span class="line">       oldTicketsCount--;</span><br><span class="line">       <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">       <span class="comment">// 解锁</span></span><br><span class="line">       pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩3张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩2张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩1张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩0张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure><p><code>mutex</code>也叫“互斥锁”，等待锁的线程处于休眠状态，不是忙等状态。  </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mutex type attributes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#define PTHREAD_MUTEX_NORMAL   0  // 正常类型</span></span><br><span class="line"> <span class="meta">#define PTHREAD_MUTEX_ERRORCHECK   1  // 错误检查</span></span><br><span class="line"> <span class="meta">#define PTHREAD_MUTEX_RECURSIVE   2  // 递归类型</span></span><br><span class="line"> <span class="meta">#define PTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_NORMAL</span></span><br></pre></td></tr></table></figure><p>  上面使用的是Normal类型同<code>OSSpinLock</code>和<code>os_unfair_lock</code>作用一样  </p><p>  <strong>递归用法</strong><br>  递归锁在被同一线程重复获取时不会产生死锁<br>  递归类型<code>PTHREAD_MUTEX_RECURSIVE</code>：</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)__initMutex:(pthread_mutex_t *)mutex</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 递归锁：允许同一个线程对一把锁进行重复加锁</span></span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 初始化属性</span></span><br><span class="line">      pthread_mutexattr_t attr;</span><br><span class="line">      pthread_mutexattr_init(&amp;attr);</span><br><span class="line">      pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">      <span class="comment">// 初始化锁</span></span><br><span class="line">      pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line">      <span class="comment">// 销毁属性</span></span><br><span class="line">      pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">         [<span class="keyword">self</span> __initMutex:&amp;_mutex];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">线程1：otherTest（+-）</span></span><br><span class="line"><span class="comment">       otherTest（+-）</span></span><br><span class="line"><span class="comment">         otherTest（+-）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">线程2：otherTest（等待）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">      pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">   </span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">         count++;</span><br><span class="line">         [<span class="keyword">self</span> otherTest];</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">      pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>条件用法</strong>  </p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_mutex_t mutex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) pthread_cond_t cond;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *data;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">         <span class="comment">// 初始化属性</span></span><br><span class="line">         pthread_mutexattr_t attr;</span><br><span class="line">         pthread_mutexattr_init(&amp;attr);</span><br><span class="line">         pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">         <span class="comment">// 初始化锁</span></span><br><span class="line">         pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">         <span class="comment">// 销毁属性</span></span><br><span class="line">         pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">       </span><br><span class="line">         <span class="comment">// 初始化条件</span></span><br><span class="line">         pthread_cond_init(&amp;_cond, <span class="literal">NULL</span>);</span><br><span class="line">       </span><br><span class="line">         <span class="keyword">self</span>.data = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">      [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__remove) object:<span class="literal">nil</span>] start];</span><br><span class="line">   </span><br><span class="line">      [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__add) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="comment">// 删除数组中的元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__remove</span><br><span class="line">&#123;</span><br><span class="line">      pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"__remove - begin"</span>);</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>.data.count == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 等待 先解锁进入等待状态</span></span><br><span class="line">         <span class="comment">// 接收到条件信号后，先加锁执行下面的代码，在解锁</span></span><br><span class="line">         pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      [<span class="keyword">self</span>.data removeLastObject];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"删除了元素"</span>);</span><br><span class="line">   </span><br><span class="line">      pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="comment">// 往数组中添加元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__add</span><br><span class="line">&#123;</span><br><span class="line">      pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">   </span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">      [<span class="keyword">self</span>.data addObject:<span class="string">@"Test"</span>];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"添加了元素"</span>);</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 信号</span></span><br><span class="line">      pthread_cond_signal(&amp;_cond);</span><br><span class="line">      <span class="comment">// 广播</span></span><br><span class="line">  <span class="comment">//    pthread_cond_broadcast(&amp;_cond);</span></span><br><span class="line">   </span><br><span class="line">      pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">      pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">      pthread_cond_destroy(&amp;_cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>NSLock、NSRecursiveLock</code><br><code>NSLock</code>是对<code>mutex</code>普通锁的封装<br><code>NSRecursiveLock</code>是对<code>mutex</code>递归锁的封装</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSLock</span> *lock;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">       <span class="comment">// 初始化</span></span><br><span class="line">       <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 加锁</span></span><br><span class="line">      [<span class="keyword">self</span>.lock lock];</span><br><span class="line">      <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">      sleep(<span class="number">.2</span>);</span><br><span class="line">      oldTicketsCount--;</span><br><span class="line">      <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      <span class="comment">// 解锁</span></span><br><span class="line">      [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩3张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩2张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩1张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩0张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure><p><code>NSRecursiveLock</code>用法与<code>NSLock</code>的用法一样。</p></li><li><p><code>NSCondition</code><br><code>NSCondition</code>是对mutex和cond的封装</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSCondition</span> *condition;</span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *data;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">         <span class="keyword">self</span>.condition = [[<span class="built_in">NSCondition</span> alloc] init];</span><br><span class="line">         <span class="keyword">self</span>.data = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">      [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__remove) object:<span class="literal">nil</span>] start];</span><br><span class="line">   </span><br><span class="line">      [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__add) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者-消费者模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="comment">// 删除数组中的元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__remove</span><br><span class="line">&#123;</span><br><span class="line">      [<span class="keyword">self</span>.condition lock];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"__remove - begin"</span>);</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>.data.count == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 等待</span></span><br><span class="line">          [<span class="keyword">self</span>.condition wait];</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      [<span class="keyword">self</span>.data removeLastObject];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"删除了元素"</span>);</span><br><span class="line">   </span><br><span class="line">      [<span class="keyword">self</span>.condition unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="comment">// 往数组中添加元素</span></span><br><span class="line">- (<span class="keyword">void</span>)__add</span><br><span class="line">&#123;</span><br><span class="line">      [<span class="keyword">self</span>.condition lock];</span><br><span class="line">   </span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">      [<span class="keyword">self</span>.data addObject:<span class="string">@"Test"</span>];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"添加了元素"</span>);</span><br><span class="line">      <span class="comment">// 信号</span></span><br><span class="line">      [<span class="keyword">self</span>.condition signal];</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 广播</span></span><br><span class="line">   <span class="comment">//    [self.condition broadcast];</span></span><br><span class="line">      [<span class="keyword">self</span>.condition unlock];</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>NSConditionLock</code><br>它是对<code>NSCondition</code>的进一步封装，可以设置具体的条件值</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSConditionLock</span> *conditionLock;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 初始化的时候 设置条件为1</span></span><br><span class="line">      <span class="keyword">self</span>.conditionLock = [[<span class="built_in">NSConditionLock</span> alloc] initWithCondition:<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__one) object:<span class="literal">nil</span>] start];</span><br><span class="line">  </span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__two) object:<span class="literal">nil</span>] start];</span><br><span class="line">  </span><br><span class="line">    [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(__three) object:<span class="literal">nil</span>] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__one</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 加锁</span></span><br><span class="line">    [<span class="keyword">self</span>.conditionLock lock];</span><br><span class="line">  </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"__one"</span>);</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 解锁时设置锁的条件为2</span></span><br><span class="line">     [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__two</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当条件为2时 加锁</span></span><br><span class="line">    [<span class="keyword">self</span>.conditionLock lockWhenCondition:<span class="number">2</span>];</span><br><span class="line">  </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"__two"</span>);</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 解锁时设置锁的条件为3</span></span><br><span class="line">     [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__three</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当条件为3时 加锁</span></span><br><span class="line">    [<span class="keyword">self</span>.conditionLock lockWhenCondition:<span class="number">3</span>];</span><br><span class="line">  </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"__three"</span>);</span><br><span class="line">     <span class="comment">// 解锁</span></span><br><span class="line">     [<span class="keyword">self</span>.conditionLock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>dispatch_queue</code><br>  直接使用GCD的串行队列，也可以实现线程同步</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">self</span>.queue = dispatch_queue_create(<span class="string">"queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.moneyQueue, ^&#123;</span><br><span class="line">         <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">         sleep(<span class="number">.2</span>);</span><br><span class="line">         oldTicketsCount--;</span><br><span class="line">         <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ticketTest</code>方法<br>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">还剩14张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩13张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩12张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩11张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩10张票 - &lt;NSThread: 0x6000003114c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">还剩9张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩8张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩7张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩6张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩5张票 - &lt;NSThread: 0x600000310cc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">还剩4张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩3张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩2张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩1张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">还剩0张票 - &lt;NSThread: 0x600000311580&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>dispatch_semaphore</code><br>信号量的初始值可以控制线程并发访问的最大值<br>初始值为1时，代表同时只允许1条线程访问资源，保证线程的同步</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) dispatch_semaphore_t semaphore;</span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) dispatch_semaphore_t ticketSemaphore;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">          <span class="comment">// 初始化</span></span><br><span class="line">          <span class="keyword">self</span>.semaphore = dispatch_semaphore_create(<span class="number">5</span>); </span><br><span class="line">          <span class="keyword">self</span>.ticketSemaphore = dispatch_semaphore_create(<span class="number">1</span>);  </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> - (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line">      <span class="comment">// 让信号量的值-1 为0 则等待，相当于加锁</span></span><br><span class="line">      dispatch_semaphore_wait(<span class="keyword">self</span>.ticketSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">      <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">    sleep(<span class="number">.2</span>);</span><br><span class="line">    oldTicketsCount--;</span><br><span class="line">    <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      <span class="comment">// 让信号量的值+1，相当于解锁</span></span><br><span class="line">      dispatch_semaphore_signal(<span class="keyword">self</span>.ticketSemaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherTest</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">          [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) object:<span class="literal">nil</span>] start];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的最大并发数为 5</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// 如果信号量的值 &gt; 0，就让信号量的值减1，然后继续往下执行代码</span></span><br><span class="line">      <span class="comment">// 如果信号量的值 &lt;= 0，就会休眠等待，直到信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码</span></span><br><span class="line">      dispatch_semaphore_wait(<span class="keyword">self</span>.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">   </span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"test - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 让信号量的值+1</span></span><br><span class="line">      dispatch_semaphore_signal(<span class="keyword">self</span>.semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  调用otherTest会发现每隔两秒打印5条信息。</p></li><li><p><code>@synchronized</code><br>  是对mutex的递归锁的封装，源码<code>objc4</code>中的<code>objc-sync.mm</code>文件查看<br>  <code>@synchronized(obj)</code>内部会生成<code>obj</code>对应的递归锁，然后进行加锁解锁操作</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saleticket &#123;</span><br><span class="line">   <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; <span class="comment">// objc_sync_enter</span></span><br><span class="line">        <span class="keyword">int</span> oldTicketsCount = <span class="keyword">self</span>.ticketsCount;</span><br><span class="line">        sleep(<span class="number">.2</span>);</span><br><span class="line">        oldTicketsCount--;</span><br><span class="line">        <span class="keyword">self</span>.ticketsCount = oldTicketsCount;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"还剩%d张票 - %@"</span>, oldTicketsCount, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">     &#125; <span class="comment">// objc_sync_exit</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;多线程使用不当会出现资源竞争，比如多个线程同时对一块资源进行修改，就会出现数据错乱的情况。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="线程同步" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>iOS 一道面试题</title>
    <link href="http://yoursite.com/2019/02/28/iOS%20%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/28/iOS 一道面试题/</id>
    <published>2019-02-28T03:04:23.474Z</published>
    <updated>2019-02-28T03:04:36.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>iOS 一道面试题<br><a id="more"></a></p></blockquote><h3 id="写出以下代码的打印结果"><a href="#写出以下代码的打印结果" class="headerlink" title="写出以下代码的打印结果"></a>写出以下代码的打印结果</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">.0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：<strong>1 3</strong></p><p><code>[self performSelector:@selector(test) withObject:nil afterDelay:.0];</code><br>这句代码的本质是往<code>Runloop</code>中添加定时器，但是子线程的<code>Runloop</code>默认是未启动的。</p><h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">.0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</code>启动<code>Runloop</code>后  </p><p>打印结果 <strong>1 3 2</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS 一道面试题&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>定制个性化 Xcode Templates</title>
    <link href="http://yoursite.com/2019/01/07/%E5%AE%9A%E5%88%B6%E4%B8%AA%E6%80%A7%E5%8C%96%20Xcode%20Templates/"/>
    <id>http://yoursite.com/2019/01/07/定制个性化 Xcode Templates/</id>
    <published>2019-01-07T07:27:58.961Z</published>
    <updated>2019-01-07T07:27:58.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当我们用Xcode的默认模板创建一个empty Swift文件的时候，在文件的顶部会带有一部分注释信息，例如文件名称等，还会默认import Foundation。其实我们如果不想显示这信息可以自己定制模板。<br><a id="more"></a></p></blockquote><p>Xcode为我们提供丰富的模板，如图：</p><p><img src="http://wx1.sinaimg.cn/mw690/006zcW7Ely1fyxv6o3ch3j314k0t87em.jpg" alt=""></p><p>使用默认模板创建一个<code>empty Swift</code>文件时，在顶部会包含一些原始数据和一个<code>import</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HQTest.swift</span></span><br><span class="line"><span class="comment">//  test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by gandijun on 2019/1/7.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HeQing. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br></pre></td></tr></table></figure><p>如果我们想每次创建文件的时候，删除这些信息，并且不每次手动删除，就需要定制个性化的模板。</p><h3 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h3><p>为了创建我们自己的模板，我们可以copy一个系统的模板，然后把它顶部的存在的代码删掉。</p><p>Xcode查找自定义模板的路径：<code>~/Library/Developer/Xcode/Templates</code>。<br>这里的文件夹在Xcode中打开时会被当成组。我们将创建一个名为<code>Custom</code>的组并且把系统自带的<code>Swift template</code>拷贝进去。</p><p>在终端中执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/Library/Developer/Xcode/Templates/Custom</span><br><span class="line">$ cp -R /Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File\ Templates/Source/Swift\ File.xctemplate ~/Library/Developer/Xcode/Templates/Custom/</span><br></pre></td></tr></table></figure><p>模板拷贝完成，我们<code>cd</code>进去看看都有什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/Library/Developer/Xcode/Templates/Custom/Swift\ File.xctemplate</span><br><span class="line">$ ls</span><br><span class="line">TemplateIcon.png          TemplateIcon@2x.png       TemplateInfo.plist        ___FILEBASENAME___.swift</span><br></pre></td></tr></table></figure><p>这里面有一些icons，一个plist文件和一个Swift的文件。打开这个swift文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat ___FILEBASENAME___.swift</span><br><span class="line">//___FILEHEADER___</span><br><span class="line"></span><br><span class="line">import Foundation</span><br></pre></td></tr></table></figure><p>这个就是系统的<code>empty swift</code>模板。<br>通过编辑器删除里面的内容，或者通过终端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm ___FILEBASENAME___.swift</span><br><span class="line">$ touch ___FILEBASENAME___.swift</span><br></pre></td></tr></table></figure><p>到这里就完成了。<br>打开Xcode创建一个新的Swift文件，选择Custom组里面的模板。<br>你会发现创建的文件的顶部的代码消失了！</p><p><img src="http://wx1.sinaimg.cn/mw690/006zcW7Ely1fyy1ux4p8dj314k0t848d.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当我们用Xcode的默认模板创建一个empty Swift文件的时候，在文件的顶部会带有一部分注释信息，例如文件名称等，还会默认import Foundation。其实我们如果不想显示这信息可以自己定制模板。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift 捕获列表Capture List</title>
    <link href="http://yoursite.com/2019/01/04/Swift%20%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8Capture%20List/"/>
    <id>http://yoursite.com/2019/01/04/Swift 捕获列表Capture List/</id>
    <published>2019-01-04T08:46:46.104Z</published>
    <updated>2019-01-04T08:46:46.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们都知道swift闭包捕获的是引用，但是swift闭包任何时候都是捕获变量的引用吗？并不是！<br><a id="more"></a></p></blockquote><h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><p>在使用<code>Swift</code>编写程序时经常使用闭包，我们都知道<code>swift</code>闭包捕获的是引用，但是<code>swift</code>闭包任何时候都是捕获变量的引用吗？并不是！有时会使用到<strong>捕获列表</strong>，我们经常使用[weak self]来防止内存泄漏。</p><p>我们来看一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> closure : () -&gt; () = &#123; <span class="built_in">print</span>(a, b) &#125;</span><br></pre></td></tr></table></figure><p>执行闭包</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closure()   <span class="comment">// 0 0</span></span><br></pre></td></tr></table></figure><p>改变a,b的值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>再次调用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closure()  <span class="comment">// 3 7</span></span><br></pre></td></tr></table></figure><p>我们可以很直观的看到现在的a,b值都改变了。<code>swift</code>的闭包中捕获到的值是捕获的引用。所以一旦你改变了这些捕获变量的值，在闭包中就会反应出来。</p><h3 id="引用类型会带来一些问题"><a href="#引用类型会带来一些问题" class="headerlink" title="引用类型会带来一些问题"></a>引用类型会带来一些问题</h3><p>很多时候，闭包的特性并不总是那么直观，很容易带来一些奇怪的错误。比如，我们创建一个<code>Array</code>，然后数组的类型是闭包</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayClosure :  [() -&gt; ()] = []</span><br></pre></td></tr></table></figure><p>执行下面的代码，将闭包添加到数组中</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> &#123;  </span><br><span class="line">    arrayClosure.append &#123; <span class="built_in">print</span>(i) &#125;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条用数组中的三个闭包看看打印值:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayClosure[<span class="number">0</span>]()<span class="comment">// 3</span></span><br><span class="line">arrayClosure[<span class="number">1</span>]()<span class="comment">// 3</span></span><br><span class="line">arrayClosure[<span class="number">2</span>]()<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>闭包打印的值都是最后一次的值。因为闭包捕获的是<strong>i</strong>的引用。如果想打印出1，2，3就要捕获到i的值。这时候就需要用到<strong>捕获列表</strong>了。</p><p>再看下面的例子，我们加了<code>[c, d] in</code> ，关键字 <code>in</code> 的左边就是我们的重点，这里表示的不是数组，而是<strong>捕获列表</strong>。一旦用了<strong>捕获列表</strong>，闭包捕获的将不是原始值的引用，而是在闭包内生成了一个原始值的copy副本。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherClosure : () -&gt; () = &#123;  [<span class="built_in">c</span>, d]  <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">c</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">c</span> = <span class="number">3</span></span><br><span class="line">d = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>调用闭包</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anotherClosure() <span class="comment">// 0, 0</span></span><br></pre></td></tr></table></figure><p>例子2修改打印1，2，3</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> &#123;  </span><br><span class="line">    arrayClosure.append &#123; [i] <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(i) </span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条用数组中的三个闭包看看打印值:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayClosure[<span class="number">0</span>]()<span class="comment">// 1</span></span><br><span class="line">arrayClosure[<span class="number">1</span>]()<span class="comment">// 2</span></span><br><span class="line">arrayClosure[<span class="number">2</span>]()<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们都知道swift闭包捕获的是引用，但是swift闭包任何时候都是捕获变量的引用吗？并不是！&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="Capture List" scheme="http://yoursite.com/tags/Capture-List/"/>
    
  </entry>
  
  <entry>
    <title>Swift 面试遇到的一道算法题</title>
    <link href="http://yoursite.com/2018/12/29/Swift%20%E9%9D%A2%E8%AF%95%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/12/29/Swift 面试遇到的一道算法题/</id>
    <published>2018-12-29T03:32:37.792Z</published>
    <updated>2019-02-28T02:38:15.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>找到一个数字<code>A</code>的下一个离他最近的比他大的数字<code>B</code>，且<code>B</code>的各位数的数字完全有<code>A</code>的各位数的数字组成。<br><a id="more"></a></p></blockquote><h4 id="一道算法题"><a href="#一道算法题" class="headerlink" title="一道算法题"></a>一道算法题</h4><p>找到一个数字<code>A</code>的下一个离他最近的比他大的数字<code>B</code>，且<code>B</code>的各位数的数字完全有<code>A</code>的各位数的数字组成。</p><p>例如：<code>A=123</code> 则<code>B=132</code>。<br>找到：<code>A=123654</code> 对应的数字<code>B</code>。</p><p>这道题用到了<strong>字典序算法</strong>。</p><p>步骤：</p><ul><li>在这个序列中从右至左找第一个左邻小于右邻的数，<code>3</code></li><li>在<code>3</code>后面的数字中找到比<code>3</code>大的数字中最小的数字<code>4</code></li><li>交换<code>3</code>和<code>4</code>的位置</li><li>最后把<code>3</code>后面的数字逆向排序</li></ul><p><code>Swift</code>代码实现</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNearestNumber</span><span class="params">(numbers: [Int])</span></span> -&gt; [<span class="type">Int</span>]? &#123;</span><br><span class="line">    <span class="keyword">var</span> numbersCopy = numbers</span><br><span class="line">    <span class="keyword">let</span> index = findTransferPoint(numbers: numbersCopy)</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    numbersCopy = exchangeHead(numbers: numbersCopy, index: index)</span><br><span class="line">    numbersCopy = <span class="built_in">reverse</span>(numbers: numbersCopy, index: index)</span><br><span class="line">    <span class="keyword">return</span> numbersCopy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这个序列中从右至左找第一个左邻小于右邻的数下标</span></span><br><span class="line"><span class="comment">// 如果找不到则这个数就是由这几个数字组成的最大的数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTransferPoint</span><span class="params">(numbers: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i, number) <span class="keyword">in</span> numbers.enumerated().reversed() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> number &gt; numbers[i-<span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换找到的数与后面比它大的数字中的最小数字的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exchangeHead</span><span class="params">(numbers: [Int], index: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> numbersCopy = numbers</span><br><span class="line">    <span class="keyword">let</span> head = numbersCopy[index-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> (i, number) <span class="keyword">in</span> numbersCopy.enumerated().reversed() &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; head &#123;</span><br><span class="line">            numbersCopy[index-<span class="number">1</span>] = number</span><br><span class="line">            numbersCopy[i] = head</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbersCopy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面数组逆向排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(numbers: [Int], index: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> numbersCopy = numbers</span><br><span class="line">    <span class="keyword">var</span> j = numbersCopy.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> index..&lt;numbersCopy.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = numbersCopy[i]</span><br><span class="line">            numbersCopy[i] = numbersCopy[j]</span><br><span class="line">            numbersCopy[j] = temp</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbersCopy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findNearestNumber(numbers: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果 [1, 2, 4, 3, 5, 6]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;找到一个数字&lt;code&gt;A&lt;/code&gt;的下一个离他最近的比他大的数字&lt;code&gt;B&lt;/code&gt;，且&lt;code&gt;B&lt;/code&gt;的各位数的数字完全有&lt;code&gt;A&lt;/code&gt;的各位数的数字组成。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>小说API</title>
    <link href="http://yoursite.com/2018/12/29/%E5%B0%8F%E8%AF%B4API/"/>
    <id>http://yoursite.com/2018/12/29/小说API/</id>
    <published>2018-12-29T03:32:37.792Z</published>
    <updated>2019-02-28T02:51:25.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抓取小说接口，自己开发小说APP练习使用<br><a id="more"></a></p></blockquote><ul><li><p><strong>小说排行榜</strong> (header 里面有个if-None-Match 后续研究)<br>  564d820bc319238a644fb408、564d8494fe996c25652644d2、54d42d92321052167dfb75e3（三个榜）<br><strong><a href="https://api.zhuishushenqi.com/ranking/564d820bc319238a644fb408" target="_blank" rel="noopener">https://api.zhuishushenqi.com/ranking/564d820bc319238a644fb408</a></strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;ranking&quot;: &#123;</span><br><span class="line">&quot;_id&quot;: &quot;564d820bc319238a644fb408&quot;,</span><br><span class="line">&quot;updated&quot;: &quot;2015-11-20T10:06:08.571Z&quot;,</span><br><span class="line">&quot;title&quot;: &quot;追书最热榜月榜男&quot;,</span><br><span class="line">&quot;tag&quot;: &quot;zhuishuMonthHotMale&quot;,</span><br><span class="line">&quot;cover&quot;: &quot;/ranking-cover/144792013856420&quot;,</span><br><span class="line">&quot;__v&quot;: 1,</span><br><span class="line">&quot;created&quot;: &quot;2019-02-21T07:06:46.904Z&quot;,</span><br><span class="line">&quot;biTag&quot;: &quot;false&quot;,</span><br><span class="line">&quot;isSub&quot;: true,</span><br><span class="line">&quot;collapse&quot;: false,</span><br><span class="line">&quot;new&quot;: true,</span><br><span class="line">&quot;gender&quot;: &quot;male&quot;,</span><br><span class="line">&quot;priority&quot;: 1000,</span><br><span class="line">&quot;books&quot;: [&#123;</span><br><span class="line">&quot;_id&quot;: &quot;5642be60f1b24c7a7468c5d7&quot;,</span><br><span class="line">&quot;title&quot;: &quot;逆鳞&quot;,</span><br><span class="line">&quot;author&quot;: &quot;柳下挥&quot;,</span><br><span class="line">&quot;shortIntro&quot;: &quot;天生废材，遭遇龙神附体。继承了神龙的意念和能力，生鳞幻爪、御水龙息、行云降雨，肉身无敌。\r\n在这个人人都想屠龙的时代，李牧羊一直生活的很有压力。&quot;,</span><br><span class="line">&quot;cover&quot;: &quot;/agent/http%3A%2F%2Fimg.1391.com%2Fapi%2Fv1%2Fbookcenter%2Fcover%2F1%2F883124%2F883124_b0e96427594e4e97bc2a7235e2b36114.jpg%2F&quot;,</span><br><span class="line">&quot;site&quot;: &quot;zhuishuvip&quot;,</span><br><span class="line">&quot;majorCate&quot;: &quot;都市&quot;,</span><br><span class="line">&quot;minorCate&quot;: &quot;都市生活&quot;,</span><br><span class="line">&quot;allowMonthly&quot;: true,</span><br><span class="line">&quot;banned&quot;: 0,</span><br><span class="line">&quot;latelyFollower&quot;: 5097,</span><br><span class="line">&quot;retentionRatio&quot;: &quot;38.2&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;id&quot;: &quot;564d820bc319238a644fb408&quot;,</span><br><span class="line">&quot;total&quot;: 183</span><br><span class="line">&#125;,</span><br><span class="line">&quot;ok&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>根据关键字搜索小说</strong><br>  例如搜索“神墓”小说<br>  <strong><a href="https://api.zhuishushenqi.com/book/fuzzy-search?query=%E7%A5%9E%E5%A2%93&amp;start=0&amp;limit=100" target="_blank" rel="noopener">https://api.zhuishushenqi.com/book/fuzzy-search?query=%E7%A5%9E%E5%A2%93&amp;start=0&amp;limit=100</a></strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;books&quot;: [&#123;</span><br><span class="line">&quot;_id&quot;: &quot;508751bef98e8f7446000024&quot;,</span><br><span class="line">&quot;hasCp&quot;: true,</span><br><span class="line">&quot;title&quot;: &quot;神墓&quot;,</span><br><span class="line">&quot;aliases&quot;: &quot;&quot;,</span><br><span class="line">&quot;cat&quot;: &quot;玄幻&quot;,</span><br><span class="line">&quot;author&quot;: &quot;辰东&quot;,</span><br><span class="line">&quot;site&quot;: &quot;zhuishuvip&quot;,</span><br><span class="line">&quot;cover&quot;: &quot;/agent/http%3A%2F%2Fimg.1391.com%2Fapi%2Fv1%2Fbookcenter%2Fcover%2F1%2F41924%2F41924_a53ddaf38363440dbf903742170dac8f.jpg%2F&quot;,</span><br><span class="line">&quot;shortIntro&quot;: &quot;我的新书《遮天》上传了，不一样的震撼与精彩，请各位书友支持。\r\n&quot;,</span><br><span class="line">&quot;lastChapter&quot;: &quot;第761章 大结局&quot;,</span><br><span class="line">&quot;retentionRatio&quot;: 49.15,</span><br><span class="line">&quot;banned&quot;: 0,</span><br><span class="line">&quot;allowMonthly&quot;: false,</span><br><span class="line">&quot;latelyFollower&quot;: 6238,</span><br><span class="line">&quot;wordCount&quot;: 2915305,</span><br><span class="line">&quot;contentType&quot;: &quot;txt&quot;,</span><br><span class="line">&quot;superscript&quot;: &quot;&quot;,</span><br><span class="line">&quot;sizetype&quot;: -1,</span><br><span class="line">&quot;highlight&quot;: &#123;</span><br><span class="line">&quot;title&quot;: [&quot;神&quot;, &quot;墓&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;total&quot;: 44,</span><br><span class="line">&quot;ok&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>根据小说类型搜索小说</strong><br>(header 里面有个if-None-Match 后续研究)<br>  例如搜索“玄幻”类型小说<br><strong><a href="https://api.zhuishushenqi.com/book/by-categories?gender=male&amp;type=hot&amp;major=%E7%8E%84%E5%B9%BB&amp;minor=&amp;start=0&amp;limit=50" target="_blank" rel="noopener">https://api.zhuishushenqi.com/book/by-categories?gender=male&amp;type=hot&amp;major=%E7%8E%84%E5%B9%BB&amp;minor=&amp;start=0&amp;limit=50</a></strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;total&quot;: 24116,</span><br><span class="line">&quot;books&quot;: [&#123;</span><br><span class="line">&quot;_id&quot;: &quot;5816b415b06d1d32157790b1&quot;,</span><br><span class="line">&quot;title&quot;: &quot;圣墟&quot;,</span><br><span class="line">&quot;author&quot;: &quot;辰东&quot;,</span><br><span class="line">&quot;shortIntro&quot;: &quot;在破败中崛起，在寂灭中复苏。沧海成尘，雷电枯竭，那一缕幽雾又一次临近大地，世间的枷锁被打开了，一个全新的世界就此揭开神秘的一角……&quot;,</span><br><span class="line">&quot;cover&quot;: &quot;/agent/http%3A%2F%2Fimg.1391.com%2Fapi%2Fv1%2Fbookcenter%2Fcover%2F1%2F1228859%2F1228859_d14f18e849b34420904ead54936e440a.jpg%2F&quot;,</span><br><span class="line">&quot;site&quot;: &quot;zhuishuvip&quot;,</span><br><span class="line">&quot;majorCate&quot;: &quot;玄幻&quot;,</span><br><span class="line">&quot;minorCate&quot;: &quot;东方玄幻&quot;,</span><br><span class="line">&quot;sizetype&quot;: -1,</span><br><span class="line">&quot;superscript&quot;: &quot;&quot;,</span><br><span class="line">&quot;contentType&quot;: &quot;txt&quot;,</span><br><span class="line">&quot;allowMonthly&quot;: false,</span><br><span class="line">&quot;banned&quot;: 0,</span><br><span class="line">&quot;latelyFollower&quot;: 150261,</span><br><span class="line">&quot;retentionRatio&quot;: 39.53,</span><br><span class="line">&quot;lastChapter&quot;: &quot;正文卷 第1375章 谁与争雄&quot;,</span><br><span class="line">&quot;tags&quot;: []</span><br><span class="line">&#125;],</span><br><span class="line">&quot;ok&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>根据小说_id搜索小说的章节</strong><br>  <strong><a href="https://api.zhuishushenqi.com/mix-toc/52159104c8f1be8010000015" target="_blank" rel="noopener">https://api.zhuishushenqi.com/mix-toc/52159104c8f1be8010000015</a></strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;mixToc&quot;: &#123;</span><br><span class="line">&quot;_id&quot;: &quot;53a2bfecfda0a68d82ff18e3&quot;,</span><br><span class="line">&quot;book&quot;: &quot;52159104c8f1be8010000015&quot;,</span><br><span class="line">&quot;chaptersCount1&quot;: 2656,</span><br><span class="line">&quot;chaptersUpdated&quot;: &quot;2017-08-19T22:29:42.305Z&quot;,</span><br><span class="line">&quot;chapters&quot;: [&#123;</span><br><span class="line">&quot;title&quot;: &quot;第一章 苍老师的女粉丝？&quot;,</span><br><span class="line">&quot;link&quot;: &quot;http://book.my716.com/getBooks.aspx?method=content&amp;bookId=685484&amp;chapterFile=774380_201601150554230375_1.txt&quot;,</span><br><span class="line">&quot;unreadble&quot;: false</span><br><span class="line">&#125;],</span><br><span class="line">&quot;updated&quot;: &quot;2018-02-10T19:33:42.612Z&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;ok&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取每章小说的内容<br>  <a href="https://chapter2.zhuishushenqi.com/chapter/http%3A%2F%2Fbook.my716.com%2FgetBooks.aspx%3Fmethod%3Dcontent%26bookId%3D685484%26chapterFile%3D774380_201601150554230375_1.txt?k=SGJGBHUSDJNCDLHK&amp;t=1550730993" target="_blank" rel="noopener">https://chapter2.zhuishushenqi.com/chapter/http%3A%2F%2Fbook.my716.com%2FgetBooks.aspx%3Fmethod%3Dcontent%26bookId%3D685484%26chapterFile%3D774380_201601150554230375_1.txt?k=SGJGBHUSDJNCDLHK&amp;t=1550730993</a></strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;ok&quot;: true,</span><br><span class="line">&quot;chapter&quot;: &#123;</span><br><span class="line">&quot;title&quot;: &quot;.&quot;,</span><br><span class="line">&quot;body&quot;: &quot;喧嚣的出站口外人流涌动，充斥着各种味道。天空上，烈日肆意地挥洒着热量，让人不由得心中烦闷。\n萧风挤出庞大的出站人流，停下脚步，狠狠地吸了口香烟，眯起略显狭长的眼睛，仰头看了眼烈日，长叹道：“阳光下的生活，真好！”\n...&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;抓取小说接口，自己开发小说APP练习使用&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>swift copy-on-write</title>
    <link href="http://yoursite.com/2018/12/29/swift%20copy-on-write/"/>
    <id>http://yoursite.com/2018/12/29/swift copy-on-write/</id>
    <published>2018-12-29T03:32:37.792Z</published>
    <updated>2019-02-28T02:34:57.781Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>swift</code>中的数组是值类型，copy的时候是直接复制的数组的完整内容。<br>但是<code>swift</code>采用了<code>copy-on-write</code>机制。<br><a id="more"></a></p></blockquote><p><code>swift</code>中的数组是值类型，copy的时候是直接复制的数组的完整内容。<br>但是<code>swift</code>采用了<code>copy-on-write</code>机制。<br>如果仅仅copy一个数组不对其进行修改，不会copy其完整的内容，仅仅引用其指针。<br>只有当对原数组进行修改的时候才会copy其完整的内容，保证了性能。</p><p>对其进行验证：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrA = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> copyA = arrA</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBufferAdd</span>&lt;T&gt;<span class="params">(<span class="number">_</span> array: [T])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.withUnsafeBufferPointer &#123; butter <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: butter.baseAddress)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getBufferAdd(arrA)  <span class="comment">// Optional(0x0000600002c070a0)</span></span><br><span class="line">getBufferAdd(copyA) <span class="comment">// Optional(0x0000600002c070a0)</span></span><br><span class="line"></span><br><span class="line">arrA.append(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">getBufferAdd(arrA)  <span class="comment">// Optional(0x0000600001d1d2e0)</span></span><br><span class="line">getBufferAdd(copyA) <span class="comment">// Optional(0x0000600002c070a0)</span></span><br></pre></td></tr></table></figure><p><code>withUnsafeBufferPointer</code>是<code>swift</code>数组的一个方法可以获取数组内容的地址将其传给闭包中的参数。我们将其转化成为字符串。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;swift&lt;/code&gt;中的数组是值类型，copy的时候是直接复制的数组的完整内容。&lt;br&gt;但是&lt;code&gt;swift&lt;/code&gt;采用了&lt;code&gt;copy-on-write&lt;/code&gt;机制。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS开发Tips" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91Tips/"/>
    
  </entry>
  
  <entry>
    <title>Tap手势和UITableView点击冲突问题</title>
    <link href="http://yoursite.com/2018/12/29/Tap%E6%89%8B%E5%8A%BF%E5%92%8CUITableView%E7%82%B9%E5%87%BB%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/12/29/Tap手势和UITableView点击冲突问题/</id>
    <published>2018-12-29T03:32:37.792Z</published>
    <updated>2018-12-29T03:40:19.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过UIGestureRecognizerDelegate解决<br><a id="more"></a></p></blockquote><h3 id="方案代码"><a href="#方案代码" class="headerlink" title="方案代码"></a>方案代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gestureRecognizer</span><span class="params">(<span class="number">_</span> gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> point = touch.location(<span class="keyword">in</span>: referenceView)</span><br><span class="line">    <span class="comment">//注意：touchView应该是referenceView的子视图</span></span><br><span class="line">    <span class="keyword">if</span> touchView.frame.<span class="built_in">contains</span>(point) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;     <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过UIGestureRecognizerDelegate解决&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="iOS开发Tips" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91Tips/"/>
    
  </entry>
  
  <entry>
    <title>Swift 用数组实现栈和队列</title>
    <link href="http://yoursite.com/2018/12/29/Swift%20%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/12/29/Swift 用数组实现栈和队列/</id>
    <published>2018-12-29T03:32:37.792Z</published>
    <updated>2019-02-28T02:30:21.473Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Swift语言中没有内设的栈和队列，可以用数组实现<br><a id="more"></a></p></blockquote><h4 id="Swift语言中没有内设的栈和队列"><a href="#Swift语言中没有内设的栈和队列" class="headerlink" title="Swift语言中没有内设的栈和队列"></a>Swift语言中没有内设的栈和队列</h4><ul><li>栈是<strong>先进后出</strong>的结构</li><li>几个基本操作：<code>push、pop、isEmpty、peek、size</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stack: [<span class="type">AnyObject</span>]</span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">return</span> stack.isEmpty &#125;</span><br><span class="line">    <span class="keyword">var</span> peek: <span class="type">AnyObject</span>? &#123; <span class="keyword">return</span> stack.last &#125;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">Int</span> &#123; <span class="keyword">return</span> stack.<span class="built_in">count</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        stack = [<span class="type">AnyObject</span>]()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(object: AnyObject)</span></span> &#123;</span><br><span class="line">        stack.append(object)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> !isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> stack.removeLast()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>队列是<strong>先进先出</strong>的结构</li><li>几个基本操作：<code>enqueue、dequeue、isEmpty、peek、size</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">left</span>: [<span class="type">AnyObject</span>]</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">right</span>: [<span class="type">AnyObject</span>]</span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">return</span> <span class="keyword">left</span>.isEmpty &amp;&amp; <span class="keyword">right</span>.isEmpty &#125;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="keyword">left</span>.<span class="built_in">count</span> + <span class="keyword">right</span>.<span class="built_in">count</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> peek: <span class="type">AnyObject</span>? &#123; <span class="keyword">return</span> <span class="keyword">left</span>.isEmpty ? <span class="keyword">right</span>.first : <span class="keyword">left</span>.last &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">left</span> = [<span class="type">AnyObject</span>]()</span><br><span class="line">        <span class="keyword">right</span> = [<span class="type">AnyObject</span>]()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(object: AnyObject)</span></span> &#123;</span><br><span class="line">        <span class="keyword">right</span>.append(object)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">left</span>.isEmpty &#123;</span><br><span class="line">            <span class="keyword">left</span> = <span class="keyword">right</span>.reversed()</span><br><span class="line">            <span class="keyword">right</span>.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">left</span>.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">left</span>.removeLast()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Swift语言中没有内设的栈和队列，可以用数组实现&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="栈和队列" scheme="http://yoursite.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Swift 排序</title>
    <link href="http://yoursite.com/2018/12/29/Swift%20%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/12/29/Swift 排序/</id>
    <published>2018-12-29T03:32:37.792Z</published>
    <updated>2019-02-28T02:01:11.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>swift自带的排序效率很高<br><a id="more"></a></p></blockquote><h3 id="swift自带的排序效率很高，总结如下"><a href="#swift自带的排序效率很高，总结如下" class="headerlink" title="swift自带的排序效率很高，总结如下"></a>swift自带的排序效率很高，总结如下</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序一个数组，升序</span></span><br><span class="line">nums.<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">nums.<span class="built_in">sort</span>(by: &gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序一个数组不改变原始数组返回一个新的排好序的数组, 升序</span></span><br><span class="line"><span class="keyword">var</span> sortedNums = nums.sorted()</span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line"><span class="keyword">var</span> sortedNums = nums.sorted(by: &gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序一个自定义对象的数组根据对象的某个属性, 升序</span></span><br><span class="line">timeIntervals.<span class="built_in">sort</span> &#123; $<span class="number">0</span>.startTime &lt; $<span class="number">1</span>.startTime &#125;</span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">timeIntervals.<span class="built_in">sort</span> &#123; $<span class="number">0</span>.startTime &gt; $<span class="number">1</span>.startTime &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据字典的key对应的value去排序一个字典的keys, 升序</span></span><br><span class="line"><span class="keyword">let</span> keys = <span class="type">Array</span>(dict.keys)</span><br><span class="line"><span class="keyword">var</span> sortedKeys = keys.sorted &#123;</span><br><span class="line">  <span class="keyword">let</span> value0 = dict[$<span class="number">0</span>]!</span><br><span class="line">  <span class="keyword">let</span> value1 = dict[$<span class="number">1</span>]!</span><br><span class="line">  <span class="keyword">return</span> value0 &lt; value1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;swift自带的排序效率很高&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS开发Tips" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91Tips/"/>
    
  </entry>
  
  <entry>
    <title>Charles抓包 http、https</title>
    <link href="http://yoursite.com/2018/12/29/Charles%E6%8A%93%E5%8C%85%20http%E3%80%81https/"/>
    <id>http://yoursite.com/2018/12/29/Charles抓包 http、https/</id>
    <published>2018-12-29T03:32:37.792Z</published>
    <updated>2019-02-28T03:17:16.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Charles抓包 http、https步骤详情记录<br><a id="more"></a></p></blockquote><h3 id="抓取http"><a href="#抓取http" class="headerlink" title="抓取http"></a>抓取http</h3><ol><li><p>打开Charles</p></li><li><p>查找电脑端ip</p><p> <img src="https://img-blog.csdnimg.cn/20190221170949452.png" alt="在这里插入图片描述"></p></li><li><p>手机端同一局域网下手动配置代理       </p><p> <img src="https://img-blog.csdnimg.cn/2019022117161879.PNG" alt="在这里插入图片描述"></p></li><li><p>手机打开任意APP请求网络，Charles会弹出确认窗口，点击同意后，可以开始抓包操作。</p></li></ol><h3 id="抓取https"><a href="#抓取https" class="headerlink" title="抓取https"></a>抓取https</h3><ol><li><p>点击Charles Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device</p><p> <img src="https://img-blog.csdnimg.cn/2019022117243467.png" alt="在这里插入图片描述"></p></li><li><p>弹出如下框</p><p> <img src="https://img-blog.csdnimg.cn/2019022117264757.png" alt="在这里插入图片描述"></p><p>在手机<code>Safari</code>浏览器输入地址 <code>chls.pro/ssl</code>，出现证书安装页面，点击安装<br>手机设置有密码的输入密码进行安装<br>如下图安装完成<br>(如果抓取Mac端数据，则在Mac的<code>Safari</code>浏览器输入地址 <code>chls.pro/ssl</code>，下载证书双击安装后在钥匙串中找到设置信任即可)</p><p> <img src="https://img-blog.csdnimg.cn/20190221172819533.jpg" alt="在这里插入图片描述"></p></li><li><p>设置-&gt;通用-&gt;关于本机-&gt;证书信任设置<br> 信任刚才的证书</p><p> <img src="https://img-blog.csdnimg.cn/20190221173046838.jpg" alt="在这里插入图片描述"></p></li><li><p>配置Charles Proxy<br> Proxy -&gt; SSL Proxying Settings</p><p> <img src="https://img-blog.csdnimg.cn/20190222084312438.png" alt="在这里插入图片描述"></p><p> 勾选Enable SSL Proxying，点击Add</p><p> <img src="https://img-blog.csdnimg.cn/20190222084527545.png" alt="在这里插入图片描述"></p><p> 填写信息，点击确认OK后，即可抓取此域名下的数据。</p><p> <img src="https://img-blog.csdnimg.cn/20190222085743582.png" alt="在这里插入图片描述"></p><p> 抓取测试</p><p> <img src="https://img-blog.csdnimg.cn/20190222085753917.png" alt="在这里插入图片描述"></p></li></ol><p>Charles注册码，感谢分享<br>Registered Name: <a href="https://zhile.io" target="_blank" rel="noopener">https://zhile.io</a><br>License Key: 48891cf209c6d32bf4<br>4.2.7版本亲测可用</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Charles抓包 http、https步骤详情记录&lt;br&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Charles" scheme="http://yoursite.com/tags/Charles/"/>
    
  </entry>
  
  <entry>
    <title>MySql数据库操作笔记</title>
    <link href="http://yoursite.com/2018/12/29/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/29/MySql数据库操作笔记/</id>
    <published>2018-12-29T03:32:37.792Z</published>
    <updated>2019-02-28T03:18:53.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MySql数据库基本操作笔记<br><a id="more"></a></p></blockquote><h3 id="命令行链接"><a href="#命令行链接" class="headerlink" title="命令行链接"></a>命令行链接</h3><ul><li><p>打开终端，运行命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">回车后输入数据库的密码</span><br></pre></td></tr></table></figure></li><li><p>链接成功后如下<br>  <img src="https://img-blog.csdnimg.cn/20190220110602870.png" alt=""></p></li><li><p>退出登录</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit 和 exit </span><br><span class="line">或</span><br><span class="line">ctrl+d</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>登陆成功后，输入如下命令查看效果 </p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看版本：<span class="keyword">select</span> <span class="keyword">version</span>();</span><br><span class="line">显示当前时间：<span class="keyword">select</span> <span class="keyword">now</span>();</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><p>查看所有数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库名;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看当前使用的数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>创建数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名 <span class="keyword">charset</span>=utf8;</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> python <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>删除数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名;</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> python;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><ul><li><p>查看当前数据库中的表</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看表结构</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名;</span><br></pre></td></tr></table></figure></li></ul><ul><li>创建表</li><li><p>auto_increment表示自动增长</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">   column1 datatype contrai,</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span>(one <span class="keyword">or</span> more <span class="keyword">columns</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  例如：创建班级表</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classes(</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> auto_increment primary <span class="keyword">key</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">   <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  例如：创建学生表</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> students(</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> primary <span class="keyword">key</span> auto_increment <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">   <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">   age tinyint <span class="keyword">unsigned</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">   height <span class="built_in">decimal</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">   gender enum(<span class="string">'男'</span>,<span class="string">'女'</span>,<span class="string">'人妖'</span>,<span class="string">'保密'</span>),</span><br><span class="line">   cls_id <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">default</span> <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改表-添加字段</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 类型;</span><br><span class="line">例：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> birthday datetime;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改表-修改字段：重命名版</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">change</span> 原名 新名 类型及约束;</span><br><span class="line">例：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">change</span> birthday birth datetime <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改表-修改字段：不重命名版</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 类型及约束;</span><br><span class="line">例：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">modify</span> birth <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改表-删除字段</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br><span class="line">例：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">drop</span> birthday;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>删除表</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line">例：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> students;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看表的创建语句</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line">例：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> classes;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;MySql数据库基本操作笔记&lt;br&gt;
    
    </summary>
    
      <category term="MySql" scheme="http://yoursite.com/categories/MySql/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
